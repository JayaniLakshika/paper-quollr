---
title: "Sample quollr"
author: "Chat-GPT"
date: "2025-09-10"
format: pdf
---

<!-- 20 pages-->

# Application

Single-cell RNA sequencing (scRNA-seq) is a popular and powerful technology that allows you to profile the whole transcriptome of a large number of individual cells [@andrews2021]. 

Clustering of single-cell data is used to identify groups of cells with similar expression profiles. NLDR often used to summarize the discovered clusters, and help to understand the results. The purpose of this example is to *illustrate how to use our method to help decide on an appropriate NLDR layout that accurately represents the data*.

Limb muscle cells of mice in @tabula2018 are examined. There are $1067$ single cells, with $14997$ gene expressions. Following their pre-processing, different NLDR methods were performed using ten principal components. Figure \@ref(fig:limb-hbe) (a) is the reproduction of the published plot. This was generated using tSNE with $\text{perplexity}=30$, the default hyper-parameters. The question is whether this accurately represents the cluster structure in the data. Note that the cluster variable is not used to produce the $2\text{-}D$ layout. 

We illustrate how to use `quollr` to assess whether this is a reasonable layout. Figure \@ref(fig:limb-hbe) shows five alternative layouts, and the HBE plot summarizing the resulting model fits. Layout b is produce by UMAP ($\text{neighbors}=5, ~\text{minimum distance}=0.1$); layout c was produced by PHATE ($\text{knn}=5$); layout d was produced by TriMAP ($\text{number of inliers}=12,~\text{outliers}=4,~\text{random}=3$); layout e was produced by by PaCMAP ($\text{neighbors}=10,~\text{init = "random"}, ~\text{MN-ratio}=0.5,~\text{FP-ratio}=2$); layout f was produced by tSNE ($\text{perplexity}=15$). 

The HBE plot indicates that the two tSNE layouts outperform all the other methods across a range of binwidths, but that the result with perplexity of $15$ outperforms the other. There are small visual difference between the two layouts. Both support that there are $5-6$ clusters. Layout a has slightly more space between clusters.  Layout d three small clusters at the top whereas layout f has only two, and another smaller one at the bottom. 

`r knitr::asis_output(if (knitr::is_html_output()) { "Figure \\@ref(fig:tsne-link-limb), \\@ref(fig:tsne-link-limb-best)"} else { "Figure \\@ref(fig:model-limb)"})` show how to examine the resulting models of the layouts overlaid on the data in high dimensions. Point color represents the cluster reported in the published paper. In each case the best model is produced using $\text{binwidth}=0.06$. A binwidth of $0.06$ is used because it is small enough to show local structure and differences between clusters, but large enough to avoid breaking the layout into too many small pieces that would make the plots hard to interpret. The plots in these figures are best understand using small steps. 

1. Examine the model in the data space for each, by looking at the tour views. In each case, the clustering doesn't quite match the separations in the data, and both models help see this. For example, the orange cluster ($1$) should probably be split into more than one cluster because both models show large stretched lines connecting a small group far from the remaining orange points. 

2. Because $6$ clusters are hard to examine together, use the menu to select just one cluster to view at at time. Selecting just cluster $1$ might help you see the explanation above, that a small group is quite separate from the main group. This suggests both the layouts and the clustering that groups these together might be wrong. Now change to focus on cluster $5$ (yellow). This group is a fairly large sparse cluster but it is separated from the other points. Both layouts are right in separating these points from the others but the fit for layout f is slightly better. 

3. To examine where the layouts differ, examine clusters $4$ (green) and $6$ (blue), by selecting just these two. Layout a has them close, but layout f has them far apart. (It might also help to include cluster $5$ here because layout a has this group close to the cluster $4$ also). In the tour view, we can see that they three clusters are separated clusters in different directions away from the most of the other points. They are both correct in this. It may have been better to place them all in different corners of the layout, but they have preserved the most important aspect that they are separated clusters. That they are all close together in layout a could be incorrectly interpreted as close in high-dimensions though.


```{r model-limb, fig.cap="Representative views of two selected NLDR layouts for the Limb muscle dataset ($n=1067$), shown row-wise. The top row (a1–a3) corresponds to the published $2\\text{-}D$ layout (Figure \\ref{fig:limb-hbe}a), and the bottom row (f1–f3) corresponds to the $2\\text{-}D$ layout selected (Figure \\ref{fig:limb-hbe}f) selected using the HBE plot. In each row, the left panel (a1, f1) shows the NLDR embedding with points coloured by muscle group and overlaid with triangulated hexagon centroids. The middle (a2, f2) and right (a3, f3) panels show two different $2\\text{-}D$ projections of the fitted model and data in the original $10\\text{-}D$ space, with the same triangular mesh displayed. Together, these panels summarize how the low-dimensional layouts relate to the underlying high-dimensional structure across different viewing directions.", fig.pos="!ht", fig.width=15, fig.height=10, eval=knitr::is_latex_output()}

set.seed(20240110)

theme_set(theme_linedraw() +
   theme(
     aspect.ratio = 1,
     plot.background = element_rect(fill = 'transparent', colour = NA),
     plot.title = element_text(size = 7, hjust = 0.5, vjust = -0.5),
     panel.background = element_rect(fill = 'transparent', 
                                     colour = NA),
     panel.grid.major = element_blank(), 
     panel.grid.minor = element_blank(), 
     axis.title.x = element_blank(), axis.title.y = element_blank(),
     axis.text.x = element_blank(), axis.ticks.x = element_blank(),
     axis.text.y = element_blank(), axis.ticks.y = element_blank(),
     legend.background = element_rect(fill = 'transparent', 
                                      colour = NA),
     legend.key = element_rect(fill = 'transparent', 
                               colour = NA),
     legend.position = "none", 
     legend.title = element_text(size=5), 
     legend.text = element_text(size=4),
     legend.key.height = unit(0.25, 'cm'),
     legend.key.width = unit(0.25, 'cm'),
     plot.margin = margin(0, 0, 0, 0)
   )

)

# Add plot label

interior_annotation <- function(label, position = c(0.9, 0.9), cex = 1, col="grey70") {
  annotation_custom(grid::textGrob(label = label,
                                   x = unit(position[1], "npc"), y = unit(position[2], "npc"),
                                   gp = grid::gpar(cex = cex, col=col)))
}

# Scale high-d data

# Center the data by subtracting the mean of each column
center_data <- function(data) {
  center_values <- colMeans(data)
  data_centered <- sweep(data, 2, center_values, FUN = "-")  # subtract means
  data_centered
}

# Function to scale data manually
# scale_data_manual <- function(data, type_col) {
#   # Step 1: Center the data (mean 0)
#   data_centered <- center_data(data |> select(-all_of(type_col)))
#
#   # Step 2: Calculate the standard deviation of each dimension
#   sds <- apply(data_centered, 2, sd)
#
#   # Step 3: Scale each dimension to have the range [0, 1]
#   data_scaled <- apply(data_centered, 2, function(col) col / max(abs(col)))
#
#   # Step 4: Scale dimensions according to their variation
#   # The dimension with the highest standard deviation is scaled to [-1, 1]
#   # Other dimensions are scaled to smaller ranges based on their standard deviations
#   max_sd <- max(sds)
#
#   # Normalize the standard deviations to get scaling factors
#   scaling_factors <- sds / max_sd
#
#   for (i in seq_along(scaling_factors)) {
#     data_scaled[, i] <- data_scaled[, i] * scaling_factors[i]
#   }
#
#   # Combine the scaled data with the 'type' column and return as a tibble
#   data_scaled <- as_tibble(data_scaled) %>%
#     mutate(!!type_col := data[[type_col]])
#
#   return(data_scaled)
# }

# Plot MSE

plot_hbe <- function(error_df) {

  ggplot(error_df,
         aes(x = a1,
             y = HBE,
             colour = method)) +
    geom_point(size = 0.8) +
    geom_line(linewidth = 0.3) +
    ylab("HBE") +
    xlab(expression(paste("binwidth (", a[1], ")"))) +
    theme_minimal() +
    theme(panel.border = element_rect(fill = 'transparent'),
          plot.title = element_text(size = 12, hjust = 0.5, vjust = -0.5),
          axis.ticks.x = element_line(),
          axis.ticks.y = element_line(),
          legend.position = "none",
          axis.text.x = element_text(size = 7),
          axis.text.y = element_text(size = 7),
          axis.title.x = element_text(size = 7),
          axis.title.y = element_text(size = 7),
          plot.margin = margin(0, 0, 0, 0))

}

# creating Standardization function
standardize = function(x){
  z <- (x - mean(x)) / sd(x)
  return( z)
}


# Solve quadratic function

quad <- function(a = 3, b = 2 * a2, c = -(a2^2 + a1^2))
{
  a <- as.complex(a)
  answer <- c((-b + sqrt(b^2 - 4 * a * c)) / (2 * a),
              (-b - sqrt(b^2 - 4 * a * c)) / (2 * a))
  if(all(Im(answer) == 0)) answer <- Re(answer)
  if(answer[1] == answer[2]) return(answer[1])
  answer[answer>0] ## only positive
}

data_limb <- read_rds("data/limb_muscles/facs_limb_muscles_pcs_10.rds")

cluster_df <- read_rds("data/limb_muscles/facs_limb_muscles_cluster_df.rds")

tsne_limb_obj <- fit_highd_model(
  highd_data = data_limb, 
  nldr_data = tsne_limb, 
  b1 = 28, 
  q = 0.1, 
  hd_thresh = 0)

df_bin_centroids_limb <- tsne_limb_obj$model_2d
df_bin_limb <- tsne_limb_obj$model_highd
trimesh_data_limb <- tsne_limb_obj$trimesh_data
tsne_limb_scaled <- tsne_limb_obj$nldr_scaled_obj$scaled_nldr

tsne_limb_scaled_with_cluster <- inner_join(tsne_limb_scaled, cluster_df, by = "ID") |>
  mutate(cluster = as.character(cluster.ids))

trimesh_limb <- ggplot() + 
  geom_point(
    data = tsne_limb_scaled_with_cluster,
    aes(
      x = emb1,
      y = emb2,
      color = cluster
    ),
    alpha = 0.3
  ) +
  geom_segment(data = trimesh_data_limb, 
               aes(
                 x = x_from, 
                 y = y_from, 
                 xend = x_to, 
                 yend = y_to),
               colour = "#000000",
               linewidth = 1,
               alpha = 0.3) +
  scale_color_manual(values = c('#66c2a5','#fc8d62','#8da0cb','#e78ac3','#a6d854','#ffd92f','#a6cee3')) +
  interior_annotation("a1", cex = 2) +
  theme(
    aspect.ratio = 1
  )

df <- inner_join(data_limb, tsne_limb_scaled_with_cluster, by = "ID")

### Define type column
df <- df |>
  select(starts_with("x"), starts_with("emb"), "cluster") |>
  mutate(type = tsne_limb_scaled_with_cluster$cluster) ## original dataset

df_b <- df_bin_limb |>
  filter(h %in% df_bin_centroids_limb$h) |>
  mutate(type = "model") ## Data with summarized mean

## Reorder the rows of df_b according to the h order in model_2d
df_b <- df_b[match(df_bin_centroids_limb$h, df_b$h),] |>
  tidyr::drop_na() |>
  select(-h)

df_exe_limb_int <- bind_rows(df_b, df)

point_data <- df_exe_limb_int 
edge_data <- trimesh_data_limb

num_highd_col <- point_data |>
  dplyr::select(starts_with("x")) |>
  NCOL()

shared_df <- crosstalk::SharedData$new(point_data)

cluster_colors <- c(
    "0" = '#66c2a5', "1" = '#fc8d62', "2" = '#8da0cb',
    "3" = '#e78ac3', "4" = '#a6d854', "5" = '#ffd92f', "6" = '#a6cee3'
)

point_sizes <- c(0, 1)

data_limb_n <- data_limb |> 
  select(-ID) |>
  mutate(type = "data")

df_b_limb <- df_bin_limb |>
  dplyr::filter(h %in% df_bin_centroids_limb$h) |>
  dplyr::mutate(type = "model") ## Data with summarized mean

## Reorder the rows of df_b according to the h order in df_b_with_center_data
df_b_limb <- df_b_limb[match(df_bin_centroids_limb$h, df_b_limb$h),] |>
  dplyr::select(-h) 

# Apply the scaling
df_model_data_limb <- bind_rows(data_limb_n, df_b_limb)
scaled_limb <- center_data(df_model_data_limb[,-11]) |>
  as_tibble() |>
  mutate(type = df_model_data_limb$type)

scaled_limb_data <- scaled_limb |>
  filter(type == "data") |>
  select(-type)

scaled_limb_data_model <- scaled_limb |>
  filter(type == "model") |>
  select(-type)

## First projection
projection <- cbind(
  c(-0.021068,0.007018,0.008770,0.016884,-0.008135,0.011458,-0.022323,0.007231,0.004976,-0.019298),
  c(-0.017371,-0.008514,0.003231,-0.022945,-0.026264,-0.001571,0.008007,-0.001268,-0.016923,-0.006700))

proj_obj1 <- get_projection(projection = projection, 
                            highd_data = scaled_limb_data, 
                            model_highd = scaled_limb_data_model, 
                            trimesh_data = trimesh_data_limb, 
                            axis_param = list(limits = 1.5,
                                              axis_scaled = 20, 
                                              axis_pos_x = -1, 
                                              axis_pos_y = -1, 
                                              threshold = 0.13))

proj_obj1[["cluster"]] <- as.character(tsne_limb_scaled_with_cluster$cluster)

limb_proj_tsne_model1 <- plot_proj(
  proj_obj = proj_obj1, 
  point_param = c(1.5, 0.2), # size, alpha, color
  line_param = c(0.5, 0.3, "#000000"),
  plot_limits = c(-1.3, 1.4), 
  axis_text_size = 4,
  is_category = TRUE) +
  interior_annotation(label = "a2", cex = 2) + 
  scale_color_manual(values = c('#66c2a5','#fc8d62','#8da0cb','#e78ac3','#a6d854','#ffd92f','#a6cee3'))

## Second projection
projection <- cbind(
  c(-0.025678,-0.017472,0.015634,-0.014868,-0.000752,0.001050,-0.019524,-0.008076,-0.010808,-0.002319),
  c(0.014526,-0.013526,-0.005147,-0.027612,-0.016919,0.005198,0.010710,0.004623,-0.007055,0.017842))

proj_obj2 <- get_projection(projection = projection, 
                            highd_data = scaled_limb_data, 
                            model_highd = scaled_limb_data_model, 
                            trimesh_data = trimesh_data_limb, 
                            axis_param = list(limits = 1.5,
                                              axis_scaled = 20, 
                                              axis_pos_x = -1, 
                                              axis_pos_y = -1, 
                                              threshold = 0.14))

proj_obj2[["cluster"]] <- as.character(tsne_limb_scaled_with_cluster$cluster)

limb_proj_tsne_model2 <- plot_proj(
  proj_obj = proj_obj2, 
  point_param = c(1.5, 0.2), # size, alpha, color
  line_param = c(0.5, 0.3, "#000000"),
  plot_limits = c(-1.3, 1.3), 
  axis_text_size = 4,
  is_category = TRUE) +
  interior_annotation(label = "a3", cex = 2) + 
  scale_color_manual(values = c('#66c2a5','#fc8d62','#8da0cb','#e78ac3','#a6d854','#ffd92f','#a6cee3'))

tsne_best_limb_obj <- fit_highd_model(
  highd_data = data_limb, 
  nldr_data = tsne_limb2, 
  b1 = 28, 
  q = 0.1, 
  hd_thresh = 0)

df_bin_centroids_limb <- tsne_best_limb_obj$model_2d
df_bin_limb <- tsne_best_limb_obj$model_highd
trimesh_data_limb <- tsne_best_limb_obj$trimesh_data
tsne_limb_scaled <- tsne_best_limb_obj$nldr_scaled_obj$scaled_nldr

tsne_limb_scaled_with_cluster <- inner_join(tsne_limb_scaled, cluster_df, by = "ID") |>
  mutate(cluster = as.character(cluster.ids))

trimesh_limb_best <- ggplot() + 
  geom_point(
    data = tsne_limb_scaled_with_cluster,
    aes(
      x = emb1,
      y = emb2,
      color = cluster
    ),
    alpha = 0.3
  ) +
  geom_segment(data = trimesh_data_limb, 
               aes(
                 x = x_from, 
                 y = y_from, 
                 xend = x_to, 
                 yend = y_to),
               colour = "#000000",
               linewidth = 1,
               alpha = 0.3) +
  scale_color_manual(values = c('#66c2a5','#fc8d62','#8da0cb','#e78ac3','#a6d854','#ffd92f','#a6cee3')) +
  interior_annotation("f1", cex = 2) +
  theme(
    aspect.ratio = 1
  )

df <- inner_join(data_limb, tsne_limb_scaled_with_cluster, by = "ID")

### Define type column
df <- df |>
  select(starts_with("x"), starts_with("emb"), "cluster") |>
  mutate(type = tsne_limb_scaled_with_cluster$cluster) ## original dataset

df_b <- df_bin_limb |>
  filter(h %in% df_bin_centroids_limb$h) |>
  mutate(type = "model") ## Data with summarized mean

## Reorder the rows of df_b according to the h order in model_2d
df_b <- df_b[match(df_bin_centroids_limb$h, df_b$h),] |>
  tidyr::drop_na() |>
  select(-h)

df_exe_limb_int <- bind_rows(df_b, df)

point_data <- df_exe_limb_int 
edge_data <- trimesh_data_limb

num_highd_col <- point_data |>
  dplyr::select(starts_with("x")) |>
  NCOL()

shared_df <- crosstalk::SharedData$new(point_data)

cluster_colors <- c(
    "0" = '#66c2a5', "1" = '#fc8d62', "2" = '#8da0cb',
    "3" = '#e78ac3', "4" = '#a6d854', "5" = '#ffd92f', "6" = '#a6cee3'
)

data_limb_n <- data_limb |> 
  select(-ID) |>
  mutate(type = "data")

df_b_limb <- df_bin_limb |>
  dplyr::filter(h %in% df_bin_centroids_limb$h) |>
  dplyr::mutate(type = "model") ## Data with summarized mean

## Reorder the rows of df_b according to the h order in df_b_with_center_data
df_b_limb <- df_b_limb[match(df_bin_centroids_limb$h, df_b_limb$h),] |>
  dplyr::select(-h) 

# Apply the scaling
df_model_data_limb <- bind_rows(data_limb_n, df_b_limb)
scaled_limb <- center_data(df_model_data_limb[,-11]) |>
  as_tibble() |>
  mutate(type = df_model_data_limb$type)

scaled_limb_data <- scaled_limb |>
  filter(type == "data") |>
  select(-type)

scaled_limb_data_model <- scaled_limb |>
  filter(type == "model") |>
  select(-type)

## First projection
projection <- cbind(
  c(-0.021068,0.007018,0.008770,0.016884,-0.008135,0.011458,-0.022323,0.007231,0.004976,-0.019298),
  c(-0.017371,-0.008514,0.003231,-0.022945,-0.026264,-0.001571,0.008007,-0.001268,-0.016923,-0.006700))

proj_obj1 <- get_projection(projection = projection, 
                            highd_data = scaled_limb_data, 
                            model_highd = scaled_limb_data_model, 
                            trimesh_data = trimesh_data_limb, 
                            axis_param = list(limits = 1.5,
                                              axis_scaled = 20, 
                                              axis_pos_x = -1, 
                                              axis_pos_y = -1, 
                                              threshold = 0.13))

proj_obj1[["cluster"]] <- as.character(tsne_limb_scaled_with_cluster$cluster)

limb_proj_tsne_best_model1 <- plot_proj(
  proj_obj = proj_obj1, 
  point_param = c(1.5, 0.2), # size, alpha, color
  plot_limits = c(-1.3, 1.4), 
  axis_text_size = 4,
  is_category = TRUE) +
  interior_annotation(label = "f2", cex = 2) + 
  scale_color_manual(values = c('#66c2a5','#fc8d62','#8da0cb','#e78ac3','#a6d854','#ffd92f','#a6cee3'))

## Second projection
projection <- cbind(
  c(-0.025678,-0.017472,0.015634,-0.014868,-0.000752,0.001050,-0.019524,-0.008076,-0.010808,-0.002319),
  c(0.014526,-0.013526,-0.005147,-0.027612,-0.016919,0.005198,0.010710,0.004623,-0.007055,0.017842))

proj_obj2 <- get_projection(projection = projection, 
                            highd_data = scaled_limb_data, 
                            model_highd = scaled_limb_data_model, 
                            trimesh_data = trimesh_data_limb, 
                            axis_param = list(limits = 1.5,
                                              axis_scaled = 20, 
                                              axis_pos_x = -1, 
                                              axis_pos_y = -1, 
                                              threshold = 0.14))

proj_obj2[["cluster"]] <- as.character(tsne_limb_scaled_with_cluster$cluster)

limb_proj_tsne_best_model2 <- plot_proj(
  proj_obj = proj_obj2, 
  point_param = c(1.5, 0.2), # size, alpha, color
  plot_limits = c(-1.3, 1.3), 
  axis_text_size = 4,
  is_category = TRUE) +
  interior_annotation(label = "f3", cex = 2) + 
  scale_color_manual(values = c('#66c2a5','#fc8d62','#8da0cb','#e78ac3','#a6d854','#ffd92f','#a6cee3'))

trimesh_limb + limb_proj_tsne_model1 +
  limb_proj_tsne_model2 + trimesh_limb_best +
  limb_proj_tsne_best_model1 + limb_proj_tsne_best_model2 +
  plot_layout(nrow = 2)
```

