---
title: "quollr: An R Package for Visualizing 2D Models from Nonlinear Dimension Reductions in High Dimensional Space"
abstract: >
  Non-Linear Dimension Reduction (NLDR) techniques have emerged as powerful tools to visualize high-dimensional data in low-diemnsioanl space. However, their complexity and (hyper)parameter choices may lead to distrustful or misleading results. The R package \CRANpkg{quollr} is developed as a new tool to help to determine which method, which (hyper)parameter choice provide the most accurate representation of $p-D$ data. Clustering data from \CRANpkg{cardinalR} package, is used to illustrate the algorithm and its use within the package.
draft: true
author:  
  - name: Jayani P.G. Lakshika
    affiliation: Monash University
    address: Department of Econometrics and Business Statistics, VIC 3800 Australia
    url: https://jayanilakshika.netlify.app/
    orcid: 0000-0002-6265-6481
    email:  \email{jayani.piyadigamage@monash.edu}
  - name: Dianne Cook
    affiliation: Monash University
    address: Department of Econometrics and Business Statistics, VIC 3800 Australia
    url: http://www.dicook.org/
    email: dicook@monash.edu
    orcid: 0000-0002-3813-7155
  - name: Paul Harrison
    affiliation: Monash University
    address: MGBP, BDInstitute, VIC 3800 Australia
    email: paul.harrison@monash.edu
    orcid: 0000-0002-3980-268X
  - name: Michael Lydeamore
    affiliation: Monash University
    address: Department of Econometrics and Business Statistics, VIC 3800 Australia
    email: michael.lydeamore@monash.edu
    orcid: 0000-0001-6515-827X
  - name: Thiyanga S. Talagala
    affiliation: University of Sri Jayewardenepura
    address: Department of Statistics, Gangodawila, Nugegoda 10100 Sri Lanka
    url: https://thiyanga.netlify.app/
    email: ttalagala@sjp.ac.lk
    orcid: 0000-0002-0656-9789
type: package
creative_commons: CC BY
date: "`r Sys.Date()`"
preamble: >
  \usepackage{amsmath}
  \usepackage{array}
output: 
 rjtools::rjournal_web_article:
    css: "style.css"
    keep_md: true
bibliography: RJreferences.bib
editor_options: 
  chunk_output_type: inline
---

```{r setup, include=FALSE}
options(repos = "https://cloud.r-project.org") ## set up CRAN mirror
knitr::opts_chunk$set(
  echo = FALSE, 
  cache=FALSE, 
  message=FALSE, 
  warning=FALSE,
  out.width = "100%")

```

```{r load-libraries}
library(quollr)
library(tibble)
library(knitr)
library(kableExtra)
library(ggplot2)
library(dplyr)
library(ggbeeswarm)
library(patchwork)
library(Rtsne)
library(readr)
library(tools)
library(cardinalR)

set.seed(20240110)
```

```{r plot-theme}
theme_set(theme_linedraw() +
   theme(
     aspect.ratio = 1,
     plot.background = element_rect(fill = 'transparent', colour = NA),
     plot.title = element_text(size = 7, hjust = 0.5, vjust = -0.5),
     panel.background = element_rect(fill = 'transparent', 
                                     colour = NA),
     panel.grid.major = element_blank(), 
     panel.grid.minor = element_blank(), 
     axis.title.x = element_blank(), axis.title.y = element_blank(),
     axis.text.x = element_blank(), axis.ticks.x = element_blank(),
     axis.text.y = element_blank(), axis.ticks.y = element_blank(),
     legend.background = element_rect(fill = 'transparent', 
                                      colour = NA),
     legend.key = element_rect(fill = 'transparent', 
                               colour = NA),
     legend.position = "none", 
     legend.title = element_text(size=5), 
     legend.text = element_text(size=4),
     legend.key.height = unit(0.25, 'cm'),
     legend.key.width = unit(0.25, 'cm')
   )

)

interior_annotation <- function(label, position = c(0.92, 0.92)) {
  annotation_custom(grid::textGrob(label = label,
      x = unit(position[1], "npc"), y = unit(position[2], "npc"),
      gp = grid::gpar(cex = 1, col="grey70")))
}
```

<!-- 20 pages-->

# Introduction

<!-- research gap: add about hexbin pkg, and emphasize that in our package provide regular hexagons-->
<!-- objective: introduce a new tool to help to determine which method, which parameter choice provide the most useful representation of high-D data.--> 
<!--intro with S-curve with 5 methods-->

This paper presents the R package, `quollr` which introduce a new visual tool in determining which NLDR technique and which (hyper)parameter choice gives most accurate representation of high-dimensional data. The methodology of the algorithm is explained in *cite the methodology paper*. Furthermore, the `quollr` package enables users to perform hexagonal binning [@dan2023], resulting in the generation of regular hexagons. The software is available from the Comprehensive R Archive Network (CARN) at [https://CRAN.R-project.org/package=quollr](https://CRAN.R-project.org/package=quollr).

The paper is organized as follows. In next section, introduces the implementation of `quollr` package on CRAN, including demonstration of the package's key functions and visualization capabilities. We illustrate the algorithm's functionality to study clustering data set in **Application** section, and describe a visual heuristic to describe parameter selection. Finally, we give a brief conclusion of the paper and discuss potential opportunities for use of our algorithm.

# Implementation

The package can be installed from CRAN:

```r
install.packages("quollr")
```

The development version can be installed from GitHub:

```r
devtools::install_github("JayaniLakshika/quollr")
```

## Package dependencies

Understanding the dependencies of the `quollr` package is essential for smooth operation and error prevention. The following dependencies refer to the other R packages that `quollr` relies on to execute its functions effectively. 

```{r}
package_dependencies("quollr")
```

## Usage

<!-- add about main function to gen 2D and highD models-->
<!--Discuss the model can be generated with bin centroids or bin means-->

## Constructing the $2\text{-}D$ model

Constructing the $2\text{-}D$ model mainly contains (i) scaling, (ii) computing hexagon grid configurations, (iii) binning, and (iv) indicating neighbors by line segments connecting centroids.

### Scaling the data

```{r}
scaled_nldr_data <- gen_scaled_data(data = s_curve_noise_umap)

scaled_nldr_data
```

### Computing hexagon grid configurations

### Binning the data

### Indicating neighbors by line segments connecting centroids

## Lifting the model into high dimensions

## Model parameters

<!--discuss about default settings-->

## Prediction

## Compute residuals and Mean Square Error (MSE)

## Visualizations

### $2\text{-}D$ model visualization

### $p\text{-}D$ model visualization

## Tests

All functions have tests written and implemented using the \CRANpkg{testthat} [@testthat] in R.

These tests illuminated the issues that allowed us to make meaningful changes and understand some pitfalls of the package.

<!--discuss a test with how a point in a intersection of two hexagonal going to evaluate-->

# Application

<!--with prism data-->
<!-- my plan is to discuss which the appropriate representation from different parameter choices from tSNE-->
<!--Why tSNE? thinking about the usability-->


```{r}
triangular_3d_data <- tri_3d(
  n = 1250, num_noise = 2, 
  min_n = -0.05, max_n = 0.05) |>
  as_tibble() 

colnames(triangular_3d_data) <- paste0("x", 1:NCOL(triangular_3d_data))
  
langevitour::langevitour(triangular_3d_data)
```

```{r}
sc_ltr_pos <- c(0.08, 0.96)

triangular_3d_data <- triangular_3d_data |>
  mutate(ID = row_number())

tSNE_fit <- triangular_3d_data |>
  select(-ID) |>
  Rtsne(perplexity = sqrt(NROW(triangular_3d_data)))

tsne_prism <- tSNE_fit$Y |>
  as_tibble() |>
  mutate(ID = row_number())

colnames(tsne_prism) <- c("tSNE1", "tSNE2", "ID")

prism_scaled_obj <- gen_scaled_data(
  data = tsne_prism)
tsne_prism_scaled <- prism_scaled_obj$scaled_nldr

nldr_prism <- tsne_prism_scaled |> 
  ggplot(aes(x = tSNE1, y = tSNE2)) + 
  geom_point(alpha=0.5, colour="#000000", size = 0.5) 

nldr_prism
```


<!--To generate errors for different total number of bins-->
```{r}
## To initialize number of bins along the x-axis
bin1_vec_prism <- 2:25 

lim1 <- prism_scaled_obj$lim1
lim2 <- prism_scaled_obj$lim2
r2_prism <- diff(lim2)/diff(lim1) 

error_prism <- data.frame(matrix(nrow = 0, ncol = 0))

for (xbins in bin1_vec_prism) {

  bin2 <- calc_bins_y(bin1 = xbins, r2 = r2_prism)$bin2

  prism_model <- fit_highd_model(
  training_data = triangular_3d_data,
  emb_df = tsne_prism_scaled,
  bin1 = xbins,
  r2 = r2_prism,
  is_bin_centroid = TRUE,
  is_rm_lwd_hex = TRUE,
  col_start_highd = "x"
)

  df_bin_centroids_prism <- prism_model$df_bin_centroids
  df_bin_prism <- prism_model$df_bin

  ## Compute error
  error_df <- glance(
    df_bin_centroids = df_bin_centroids_prism,
    df_bin = df_bin_prism,
    training_data = triangular_3d_data,
    newdata = NULL,
    type_NLDR = "tSNE",
    col_start = "x") |>
    mutate(bin1 = xbins,
           bin2 = bin2,
           b = bin1 * bin2,
           b_non_empty = NROW(df_bin_centroids_prism))

  error_prism <- bind_rows(error_prism, error_df)

}

mse_prism_b <- ggplot(error_prism, 
                     aes(x = b, 
                         y = log(MSE))) + 
  geom_point(size = 1) +
  geom_line() + 
  geom_vline(xintercept = 420, linetype="solid", 
             color = "black", linewidth=0.8, alpha = 0.5) +
  ylab("log(MSE)") +
  xlab("b") +
  theme(axis.text.x = element_text(size = 7),
        axis.text.y = element_text(size = 7),
        axis.title.x = element_text(size = 7),
        axis.title.y = element_text(size = 7, angle = 90))

mse_prism_b
```

```{r}
## Compute hexbin parameters
num_bins_x_prism <- 20
lim1 <- prism_scaled_obj$lim1
lim2 <- prism_scaled_obj$lim2
r2_prism <- diff(lim2)/diff(lim1) 

prism_model <- fit_highd_model(
  training_data = triangular_3d_data,
  emb_df = tsne_prism_scaled,
  bin1 = num_bins_x_prism,
  r2 = r2_prism,
  is_bin_centroid = TRUE,
  is_rm_lwd_hex = TRUE,
  col_start_highd = "x"
)

df_bin_centroids_prism <- prism_model$df_bin_centroids
df_bin_prism <- prism_model$df_bin

## Triangulate bin centroids
tr1_object_prism <- tri_bin_centroids(
  df_bin_centroids_prism, x = "c_x", y = "c_y")
tr_from_to_df_prism <- gen_edges(
  tri_object = tr1_object_prism)

## Compute 2D distances
distance_prism <- cal_2d_dist(
  tr_coord_df = tr_from_to_df_prism,
  start_x = "x_from",
  start_y = "y_from",
  end_x = "x_to",
  end_y = "y_to",
  select_vars = c("from", "to", "distance"))

## To find the benchmark value
benchmark_prism <- find_lg_benchmark(
  distance_edges = distance_prism,
  distance_col = "distance")

trimesh_removed_prism <- vis_rmlg_mesh(
  distance_edges = distance_prism,
  benchmark_value = benchmark_prism,
  tr_coord_df = tr_from_to_df_prism,
  distance_col = "distance") #+
  #xlim(sc_xlims) + ylim(sc_ylims) +
  #interior_annotation("a", sc_ltr_pos)

trimesh_removed_prism
```

```{r}
## Hexagonal binning to have regular hexagons
hb_obj_prism <- hex_binning(
  data = tsne_prism_scaled,
  bin1 = num_bins_x_prism,
  r2 = r2_prism)

tsne_data_with_hb_id <- hb_obj_prism$data_hb_id

df_all_prism <- dplyr::bind_cols(triangular_3d_data |> dplyr::select(-ID),
                                tsne_data_with_hb_id)

### Define type column
df <- df_all_prism |>
  dplyr::select(tidyselect::starts_with("x")) |>
  dplyr::mutate(type = "data") ## original dataset

df_b <- df_bin_prism |>
  dplyr::filter(hb_id %in% df_bin_centroids_prism$hexID) |>
  dplyr::mutate(type = "model") ## Data with summarized mean

## Reorder the rows of df_b according to the hexID order in df_b_with_center_data
df_b <- df_b[match(df_bin_centroids_prism$hexID, df_b$hb_id),] |>
  dplyr::select(-hb_id)

df_exe <- dplyr::bind_rows(df_b, df)

## Set the maximum difference as the criteria
distance_df_small_edges <- distance_prism |>
  dplyr::filter(distance < benchmark_prism)
## Since erase brushing is considerd.

langevitour::langevitour(df_exe[1:(length(df_exe)-1)],
                         lineFrom = distance_df_small_edges$from,
                         lineTo = distance_df_small_edges$to,
                         group = df_exe$type, pointSize = append(rep(0, NROW(df_b)), rep(0.8, NROW(df))),
                         levelColors = c("#6a3d9a", "#33a02c"))
```

# Discussion

This paper presents the R package `quollr` to develop a way to take the fitted model, as represented by the positions of points in 2D, and turn it into a high-dimensional wireframe to overlay on the data, viewing it with a tour.

The paper includes a clustering example to illustrate how `quollr` is useful to assess which NLDR technique and which (hyper)parameter choice gives the most accurate representation. In addition, how to select parameters for hexagonal binning and fitting model are explained.

Possible future improvements would be...<!--assess the preservation of local and glocal structure w.r.t 2D and high-D distance comparison--> 

This new tool provides an effective start point for automatically creating regular hexagons and help to evaluate which NLDR technique and which hyperparameter choice gives the most accurate representation of $p-D$ data.

# Acknowledgements

This article is created using \CRANpkg{knitr} [@knitr] and \CRANpkg{rmarkdown} [@rmarkdown] in R with the `rjtools::rjournal_article` template. The source code for reproducing this paper can be found at: <https://github.com/JayaniLakshika/paper-quollr>.
