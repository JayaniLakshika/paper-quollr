---
title: "quollr: An R Package for Visualizing 2-D Models from Non-linear Dimension Reductions in High Dimensional Space"
abstract: >
  Non-linear dimension reduction (NLDR) methods provide a low-dimensional representation of high-dimensional data ($p\text{-}D$) by applying a non-linear transformation. However, the complexity of the transformations and data structures can create wildly different representations depending on the method and hyper-parameter choices. It is difficult to determine whether any of these representations are accurate, which one is the best, or whether they have missed important structures. The R package \CRANpkg{quollr} has been developed as a new visual tool to determine which method and which hyper-parameter choices provide the most accurate representation of high-dimensional data. The `scurve` data from the package is used to illustrate the algorithm. Single-cell RNA sequencing (scRNA-seq) data from mouse limb muscles are used to demonstrate the usability of the package.
draft: true
author:  
  - name: Jayani P. Gamage
    affiliation: Monash University
    address: Department of Econometrics and Business Statistics, VIC 3800 Australia
    url: https://jayanilakshika.netlify.app/
    orcid: 0000-0002-6265-6481
    email:  \email{jayani.piyadigamage@monash.edu}
  - name: Dianne Cook
    affiliation: Monash University
    address: Department of Econometrics and Business Statistics, VIC 3800 Australia
    url: http://www.dicook.org/
    email: dicook@monash.edu
    orcid: 0000-0002-3813-7155
  - name: Paul Harrison
    affiliation: Monash University
    address: MGBP, BDInstitute, VIC 3800 Australia
    email: paul.harrison@monash.edu
    orcid: 0000-0002-3980-268X
  - name: Michael Lydeamore
    affiliation: Monash University
    address: Department of Econometrics and Business Statistics, VIC 3800 Australia
    email: michael.lydeamore@monash.edu
    orcid: 0000-0001-6515-827X
  - name: Thiyanga S. Talagala
    affiliation: University of Sri Jayewardenepura
    address: Department of Statistics, Gangodawila, Nugegoda 10100 Sri Lanka
    url: https://thiyanga.netlify.app/
    email: ttalagala@sjp.ac.lk
    orcid: 0000-0002-0656-9789
type: package
creative_commons: CC BY
date: "`r Sys.Date()`"
preamble: >
  \usepackage{amsmath}
  \usepackage{array}
  \usepackage{float}
output: 
 rjtools::rjournal_article:
    keep_md: true
bibliography: paper-quollr.bib
editor_options: 
  chunk_output_type: inline
---

```{r setup, include=FALSE}
options(repos = "https://cloud.r-project.org") ## set up CRAN mirror
knitr::opts_chunk$set(
  echo = FALSE, 
  cache=FALSE, 
  message=FALSE, 
  warning=FALSE,
  comment = ">",
  out.width = "100%")

```

```{r install-libraries, include=FALSE, warning=FALSE, echo=FALSE}

options(repos = c(CRAN = "https://cran.rstudio.com")) # Setup mirror

packages_to_check <- c("remotes", "quollr", "tibble", "knitr", "kableExtra", "ggplot2", "dplyr", "patchwork", "readr", "plotly", "crosstalk", "htmltools")

for (pkg in packages_to_check) {
  if (!requireNamespace(pkg, quietly = TRUE)) {
    message(paste("Installing package:", pkg))
    install.packages(pkg)
  } else {
    installed_version <- packageVersion(pkg)
    available_version <- tryCatch({
      utils::packageDescription(pkg)$Version
    }, error = function(e) NA) # Handle cases where package info isn't readily available

    if (!is.na(available_version) && installed_version < package_version(available_version)) {
      message(paste("A newer version of package", pkg, "is available. Updating..."))
      install.packages(pkg)
    } else {
      message(paste("Package", pkg, "is up-to-date (version", installed_version, ")."))
    }
  }
}

```

```{r load-libraries}
library(quollr)
library(tibble)
library(knitr)
library(kableExtra)
library(ggplot2)
library(dplyr)
library(patchwork)
library(readr)
library(plotly)
library(crosstalk)
library(htmltools)

set.seed(20240110)
```

```{r plot-theme}
theme_set(theme_linedraw() +
   theme(
     aspect.ratio = 1,
     plot.background = element_rect(fill = 'transparent', colour = NA),
     plot.title = element_text(size = 7, hjust = 0.5, vjust = -0.5),
     panel.background = element_rect(fill = 'transparent', 
                                     colour = NA),
     panel.grid.major = element_blank(), 
     panel.grid.minor = element_blank(), 
     axis.title.x = element_blank(), axis.title.y = element_blank(),
     axis.text.x = element_blank(), axis.ticks.x = element_blank(),
     axis.text.y = element_blank(), axis.ticks.y = element_blank(),
     legend.background = element_rect(fill = 'transparent', 
                                      colour = NA),
     legend.key = element_rect(fill = 'transparent', 
                               colour = NA),
     legend.position = "none", 
     legend.title = element_text(size=5), 
     legend.text = element_text(size=4),
     legend.key.height = unit(0.25, 'cm'),
     legend.key.width = unit(0.25, 'cm'),
     plot.margin = margin(0, 0, 0, 0)
   )

)
```

```{r}
#| label: import-scripts
source("scripts/additional_functions.R")
```

<!-- 20 pages-->

# Introduction

<!-- research gap: add about hexbin pkg, and emphasize that in our package provide regular hexagons-->
<!-- objective: introduce a new tool to help to determine which method, which parameter choice provide the most useful representation of high-D data.--> 
<!--intro with S-curve with 5 methods-->

Non-linear dimension reduction (NLDR) techniques, such as t-distributed stochastic neighbor embedding (tSNE) [@laurens2008], uniform manifold approximation and projection (UMAP) [@leland2018], potential of heat-diffusion for affinity-based trajectory embedding (PHATE) algorithm [@moon2019], large-scale dimensionality reduction Using triplets (TriMAP) [@amid2019], and pairwise controlled manifold approximation (PaCMAP) [@yingfan2021], create wildly different representations depending on the selected method and hyper-parameter choices. It is difficult to determine whether any of these representations are accurate, which one is the best, or whether they have missed important structures. 

This paper presents the R package, `quollr`, which is useful for understanding how NLDR warps high-dimensional space and fits the data. Starting with an NLDR layout, our approach is to create a wireframe model representation, that can be lifted and displayed in the high-dimensional space (`r knitr::asis_output(if (knitr::is_html_output()) { "Figure \\@ref(fig:overviewhtml)"} else { "Figure \\@ref(fig:overview)"})`).

```{r}
clr_choice <- "#66B2CC"

scurve_model_obj <- fit_highd_model(
  highd_data = scurve, 
  nldr_data = scurve_umap, 
  b1 = 15, 
  q = 0.1, 
  benchmark_highdens = 1)

scurve_umap_scaled <- scurve_model_obj$nldr_obj$scaled_nldr
tr_from_to_df_scurve <- scurve_model_obj$trimesh_data
df_bin_centroids_scurve <- scurve_model_obj$model_2d
df_bin_scurve <- scurve_model_obj$model_highd
hex_grid_scurve <- scurve_model_obj$hb_obj$hex_poly
counts_df_scurve <- scurve_model_obj$hb_obj$std_cts

hex_grid_with_counts_scurve <- left_join(
  hex_grid_scurve, counts_df_scurve, 
  by = c("h" = "h"))

hex_grid_nonempty_scurve <- hex_grid_scurve |>
  filter(h %in% df_bin_centroids_scurve$h)

sc_xlims <- c(-0.25, 1.25)
sc_ylims <- c(-0.25, 1.25)

scurve_umap_plt <- ggplot(
  scurve_umap_scaled, 
  aes(x = emb1, y = emb2)) +
  geom_point(alpha = 0.5, color = clr_choice, size = 0.5) +
  interior_annotation("a") +
  xlim(sc_xlims) +
  ylim(sc_ylims)

scurve_umap_plt_int <- ggplotly(scurve_umap_plt, 
                                width = "230", 
                                height = "230", 
                                tooltip = "none") |>
  config(
    staticPlot = TRUE,        # Disables all interactivity (no hover, zoom, pan)
    displayModeBar = FALSE,   # Hides the plotly toolbar
    editable = FALSE,         # Disables annotations and editing
    showTips = FALSE,         # Removes tooltip on hover
    displaylogo = FALSE,      # Hides plotly logo
    responsive = FALSE        # Disables responsive resizing
  )

hex_grid_poly_scurve <- ggplot(
  data = hex_grid_with_counts_scurve, 
  aes(x = x, y = y)) +
  geom_polygon(color = "grey70", 
               aes(group = h), 
               fill = "#ffffff") +
  geom_point(data = scurve_umap_scaled, 
             aes(x = emb1, y = emb2), 
             alpha = 0.2, size = 0.5, color = clr_choice) + 
  interior_annotation("b") +
  xlim(sc_xlims) +
  ylim(sc_ylims)

hex_grid_poly_scurve_int <- ggplotly(hex_grid_poly_scurve, 
                                width = "230", 
                                height = "230", 
                                tooltip = "none") |>
  config(
    staticPlot = TRUE,        # Disables all interactivity (no hover, zoom, pan)
    displayModeBar = FALSE,   # Hides the plotly toolbar
    editable = FALSE,         # Disables annotations and editing
    showTips = FALSE,         # Removes tooltip on hover
    displaylogo = FALSE,      # Hides plotly logo
    responsive = FALSE        # Disables responsive resizing
  )

hex_centroids_scurve <- ggplot(
  data = hex_grid_with_counts_scurve, 
  aes(x = x, y = y)) +
  geom_polygon(color = "grey70", 
               aes(group = h), 
               fill = "#ffffff")  +
  geom_point(data = df_bin_centroids_scurve, 
             aes(x = c_x, y = c_y), 
             size = 1, color = "#FF7755") +
  interior_annotation("c") +
  xlim(sc_xlims) +
  ylim(sc_ylims)

hex_centroids_scurve_int <- ggplotly(hex_centroids_scurve, 
                                width = "230", 
                                height = "230", 
                                tooltip = "none") |>
  config(
    staticPlot = TRUE,        # Disables all interactivity (no hover, zoom, pan)
    displayModeBar = FALSE,   # Hides the plotly toolbar
    editable = FALSE,         # Disables annotations and editing
    showTips = FALSE,         # Removes tooltip on hover
    displaylogo = FALSE,      # Hides plotly logo
    responsive = FALSE        # Disables responsive resizing
  )

wireframe_scurve <- ggplot() +
  geom_segment(data = tr_from_to_df_scurve,
               aes(
                 x = x_from,
                 y = y_from,
                 xend = x_to,
                 yend = y_to),
               colour = "#000000") +
  geom_point(data = df_bin_centroids_scurve, 
             aes(x = c_x, y = c_y), 
             size = 1, color = "#FF7755") +
  interior_annotation("d") +
  xlim(sc_xlims) +
  ylim(sc_ylims)

wireframe_scurve_int <- ggplotly(wireframe_scurve, 
                                width = "230", 
                                height = "230", 
                                tooltip = "none") |>
  config(
    staticPlot = TRUE,        # Disables all interactivity (no hover, zoom, pan)
    displayModeBar = FALSE,   # Hides the plotly toolbar
    editable = FALSE,         # Disables annotations and editing
    showTips = FALSE,         # Removes tooltip on hover
    displaylogo = FALSE,      # Hides plotly logo
    responsive = FALSE        # Disables responsive resizing
  )

## 2-d vis model
hex_grid_scurve <- ggplot(
  data = hex_grid_with_counts_scurve, 
  aes(x = x, y = y)) +
  geom_point(data = scurve_umap_scaled, 
             aes(x = emb1, y = emb2), 
             size = 0.5, color = clr_choice) +
  geom_segment(data = tr_from_to_df_scurve,
               aes(
                 x = x_from,
                 y = y_from,
                 xend = x_to,
                 yend = y_to),
               colour = "#000000") +
  geom_point(data = df_bin_centroids_scurve, 
             aes(x = c_x, y = c_y), 
             size = 1, color = "#FF7755")

hex_grid_scurve_int <- ggplotly(hex_grid_scurve, 
                                width = "350", 
                                height = "350", 
                                tooltip = "none") |>
  config(
    staticPlot = TRUE,        # Disables all interactivity (no hover, zoom, pan)
    displayModeBar = FALSE,   # Hides the plotly toolbar
    editable = FALSE,         # Disables annotations and editing
    showTips = FALSE,         # Removes tooltip on hover
    displaylogo = FALSE,      # Hides plotly logo
    responsive = FALSE        # Disables responsive resizing
  )


## High-d vis model
df_exe <- comb_data_model(
    highd_data = scurve, 
    model_highd = df_bin_scurve, 
    model_2d = df_bin_centroids_scurve
)

df <- df_exe |>
    dplyr::filter(type == "data") ## original dataset

df_b <- df_exe |>
  dplyr::filter(type == "model") ## High-d model

scurve_umap_model_vis <- langevitour::langevitour(df_exe[1:(length(df_exe)-1)],
                         lineFrom = tr_from_to_df_scurve$from,
                         lineTo = tr_from_to_df_scurve$to,
                         group = df_exe$type,
                         pointSize = append(rep(2, NROW(df_b)), rep(1, NROW(df))),
                         levelColors = c(clr_choice, "#FF7755"),
                         enableControls = FALSE,
                         width = "421px", height = "421px")

scurve_umap_model_vis_n <- langevitour::langevitour(df_exe[1:(length(df_exe)-1)],
                         lineFrom = tr_from_to_df_scurve$from,
                         lineTo = tr_from_to_df_scurve$to,
                         group = df_exe$type,
                         pointSize = append(rep(2, NROW(df_b)), rep(1, NROW(df))),
                         levelColors = c(clr_choice, "#FF7755"),
                         enableControls = FALSE,
                         width = "300px", height = "300px")

```

```{r overviewhtml, eval=knitr::is_html_output(), fig.cap="algorithm", fig.pos='H'}

overviewfig <- bscols(
  htmltools::div(
    style = "display: grid; grid-template-columns: 1fr 1fr;",
    hex_grid_scurve_int,
    htmltools::div(style = "margin-top: 13px;", scurve_umap_model_vis)
  ),
  device = "xs"
)

class(overviewfig) <- c(class(overviewfig), "htmlwidget")

overviewfig
```

```{r scurve-projections}

df_b_scurve <- df_bin_scurve |>
  dplyr::filter(h %in% df_bin_centroids_scurve$h) |>
  dplyr::mutate(type = "model") ## Data with summarized mean

## Reorder the rows of df_b according to the h order in df_b_with_center_data
df_b_scurve <- df_b_scurve[match(df_bin_centroids_scurve$h, df_b_scurve$h),] |>
  dplyr::select(-h) 

scurve_labeled <- scurve |>
  select(-ID) |>
  mutate(type = "data")

# Apply the scaling
df_model_data_scurve <- bind_rows(scurve_labeled, df_b_scurve)
scaled_scurve <- scale_data_manual(df_model_data_scurve, "type") |>
  as_tibble()

scaled_scurve_data <- scaled_scurve |>
  filter(type == "data") |>
  select(-type)

scaled_scurve_data_model <- scaled_scurve |>
  filter(type == "model") |>
  select(-type)


## First projection
projection <- cbind(
  c(0.10479,0.06673,0.19430,-0.14763,0.02861,-0.04302,0.06601),
  c(0.11421,0.18556,-0.16860,-0.05033,-0.00219,0.04159,0.04285))

proj_obj1 <- get_projection(projection = projection, 
                            proj_scale = 1.23, 
                            highd_data = scaled_scurve_data, 
                            model_highd = scaled_scurve_data_model, 
                            trimesh_data = tr_from_to_df_scurve, 
                            axis_param = list(limits = 0.5, 
                                              axis_scaled = 2,
                                              axis_pos_x = -0.25, 
                                              axis_pos_y = -0.25, 
                                              threshold = 0.0259))

scurve_proj_umap_model1 <- plot_proj(
  proj_obj = proj_obj1,
  point_param = c(0.5, 0.2, clr_choice), # size, alpha, color
  plot_limits = c(-0.35, 0.35), 
  axis_text_size = 3,
  is_category = FALSE) +
  interior_annotation(label = "a1", cex = 1) 

## Second projection

projection <- cbind(
  c(0.01588,-0.13640,-0.17180,-0.15486,-0.09726,0.00858,0.01090),
  c(0.21443,-0.00390,0.08182,-0.11746,0.06820,-0.05458,-0.08885))

proj_obj2 <- get_projection(projection = projection, 
                            proj_scale = 1.23, 
                            highd_data = scaled_scurve_data, 
                            model_highd = scaled_scurve_data_model, 
                            trimesh_data = tr_from_to_df_scurve, 
                            axis_param = list(limits = 0.5, 
                                              axis_scaled = 2,
                                              axis_pos_x = -0.25, 
                                              axis_pos_y = -0.25, 
                                              threshold = 0.0259))

scurve_proj_umap_model2 <- plot_proj(
  proj_obj = proj_obj2,
  point_param = c(0.5, 0.2, clr_choice), # size, alpha, color
  plot_limits = c(-0.35, 0.35), 
  axis_text_size = 3,
  is_category = FALSE) +
  interior_annotation(label = "a2", cex = 1) 

## Third projection

projection <- cbind(
  c(0.02727,0.09154,-0.16383,-0.04931,-0.17013,0.11965,-0.01884),
  c(-0.10510,-0.10971,-0.09084,0.19642,-0.07163,-0.02486,0.07965))

proj_obj3 <- get_projection(projection = projection, 
                            proj_scale = 1.23, 
                            highd_data = scaled_scurve_data, 
                            model_highd = scaled_scurve_data_model, 
                            trimesh_data = tr_from_to_df_scurve, 
                            axis_param = list(limits = 0.5, 
                                              axis_scaled = 2,
                                              axis_pos_x = -0.25, 
                                              axis_pos_y = -0.25, 
                                              threshold = 0.031))

scurve_proj_umap_model3 <- plot_proj(
  proj_obj = proj_obj3,
  point_param = c(0.5, 0.2, clr_choice), # size, alpha, color
  plot_limits = c(-0.35, 0.35), 
  axis_text_size = 3,
  is_category = FALSE) +
  interior_annotation(label = "a3", cex = 1) 

## Fourth projection

projection <- cbind(
  c(0.17174,0.14255,0.11950,0.10344,-0.07148,-0.01656,0.04275),
  c(0.09270,0.04486,-0.14397,0.08305,0.11783,0.16187,-0.06077))

proj_obj4 <- get_projection(projection = projection, 
                            proj_scale = 1.23, 
                            highd_data = scaled_scurve_data, 
                            model_highd = scaled_scurve_data_model, 
                            trimesh_data = tr_from_to_df_scurve, 
                            axis_param = list(limits = 0.5, 
                                              axis_scaled = 2,
                                              axis_pos_x = -0.25, 
                                              axis_pos_y = -0.25, 
                                              threshold = 0.031))

scurve_proj_umap_model4 <- plot_proj(
  proj_obj = proj_obj4,
  point_param = c(0.5, 0.2, clr_choice), # size, alpha, color
  plot_limits = c(-0.35, 0.35), 
  axis_text_size = 3,
  is_category = FALSE) +
  interior_annotation(label = "a4", cex = 1) 
```

```{r overview, eval=knitr::is_latex_output(), fig.cap="Wireframe model representation of the NLDR layout, lifted and displayed in high-dimensional space. The left panel shows the NLDR layout with a triangular mesh overlay, forming the wireframe structure. This mesh can be lifted into higher dimensions and projected to examine how the geometric structure of the data is preserved. Panels (a1–a4) display different $2\text{-}D$ projections of the lifted wireframe, where the underlying curved sheet structure of the data is more clearly visible. The triangulated mesh highlights how local neighborhoods in the layout correspond to relationships in the high-dimensional space, enabling diagnostics of distortion and preservation across dimensions.", fig.pos='H'}
hex_grid_scurve + wrap_plots(
  scurve_proj_umap_model1, scurve_proj_umap_model2,
  scurve_proj_umap_model3, scurve_proj_umap_model4, 
  ncol = 2)
```

The paper is organized as follows. The next section introduces the implementation of the `quollr` package on CRAN, including a demonstration of the package's key functions and visualization capabilities. In the application section, we illustrate the algorithm's functionality for studying a clustering data structure. Finally, we conclude the paper with a brief summary and discuss potential opportunities for using our algorithm.

# Algorithm

Our algorithm includes the following steps: (1) scaling the NLDR data, (2) computing configurations of a hexagon grid, (3) binning the data, (4) obtaining the centroids of each bin, (5) indicating neighboring bins with line segments that connect the centroids, and (6) lifting the model into high dimensions (`r knitr::asis_output(if (knitr::is_html_output()) { "Figure \\@ref(fig:algo-step-html)"} else { "Figure \\@ref(fig:algo-steps)"})`). A detailed description of the algorithm can be found in @gamage2025c.

```{r algo-step-html, eval=knitr::is_html_output(), out.width="100%", fig.height=5, fig.width=25, fig.pos='H', fig.cap="Key steps for constructing the model on the UMAP layout: (a) NLDR data, (b) hexagon bins, (c) bin centroids, (d) triangulated centroids, and (e) lifting the model into high dimensions. The `Scurve` data is shown."}

algofig <- crosstalk::bscols(
        htmltools::div(style="display: grid; grid-template-columns: 1fr 1fr 1fr 1fr 1fr; gap: 0;",
                       htmltools::div(style = "margin: 0; padding: 0;", scurve_umap_plt_int),
                       htmltools::div(style = "margin: 0; padding: 0;", hex_grid_poly_scurve_int),
                       htmltools::div(style = "margin: 0; padding: 0;", hex_centroids_scurve_int),
                       htmltools::div(style = "margin: 0; padding: 0;", wireframe_scurve_int),
                       htmltools::div(
                         style = "margin-top: 13px;t",
                         scurve_umap_model_vis_n
                       )),
        device = "xs"
      )

class(algofig) <- c(class(algofig), "htmlwidget")

algofig
```

```{r algo-steps, eval=knitr::is_latex_output(), out.width="100%", fig.height=5, fig.width=25, fig.pos='H', fig.cap="Key steps for constructing the model on the UMAP layout: (a) NLDR data, (b) hexagon bins, (c) bin centroids, (d) triangulated centroids, and (e) lifting the model into high dimensions. The `Scurve` data is shown."}

scurve_umap_plt + hex_grid_poly_scurve +
  hex_centroids_scurve + wireframe_scurve + 
  scurve_proj_umap_model1 +
  plot_layout(ncol = 5)
```

# Implementation

## Installation

The development version can be installed from GitHub:

```r
pak::pak("JayaniLakshika/quollr")
```

## Usage

The following demonstration of the package's functionality assumes `quollr` has been loaded. We also want to load the built-in data sets `scurve` and `scurve_umap`. 

`scurve` is a $7\text{-}D$ simulated dataset. It is constructed by simulating $1000$ observations from $\theta \sim U(-3\pi/2, 3\pi/2)$, $X_1 = \sin(\theta)$, $X_2 \sim U(0, 2)$ (adding thickness to the S), $X_3 = \text{sign}(\theta) \times (\cos(\theta) - 1)$. The remaining variables $X_4$, $X_5$, $X_6$, $X_7$ are all uniform error, with small variance. `scurve_umap` is the UMAP $2\text{-}D$ embedding for `scurve` data with `n_neighbors` is $46$ and `min_dist` is $0.9$. Each data set contains a unique ID column that maps `scurve` and `scurve_umap`. 

### Main function

The mains steps for the algorithm can be executed by the main function `fit_highd_model()`, or can be run separately for more flexibility. 

<!-- If a user would like to perform steps of the algorithm themselves, additional user input will be needed for the function that perform each step. For example, if the user wishes to use already binning data, the `extract_hexbin_centroids()` function can be used directly. -->

This function requires several parameters: the high-dimensional data (`highd_data`), the emdedding data (`nldr_data`), the number of bins along the x-axis (`b1`), the buffer amount as a proportion of data (`q`), and benchmark value to extract high density hexagons (`benchmark_highdens`). The function returns an object that includes the scaled NLDR object (`nldr_obj`), the hexagonal object (`hb_obj`), the fitted model in both $2\text{-}D$ (`model_2d`), and $p\text{-}D$ (`model_highd`), and triangular mesh (`trimesh_data`).  

```{r, echo=TRUE, eval=FALSE}
fit_highd_model(
  highd_data = scurve, 
  nldr_data = scurve_umap, 
  b1 = 15, 
  q = 0.1, 
  benchmark_highdens = 1)
```

### Constructing the $2\text{-}D$ Model

Constructing the $2\text{-}D$ model primarily involves (i) scaling the NLDR data, (ii) binning the data, (iii) obtaining bin centroids, (iv) connecting centroids with line segments to indicate neighbors, and (v) Remove low-density hexagons.

#### Scaling the data

The algorithm starts by scaling the NLDR data to a standard range using the `gen_scaled_data()` function. This function standardizes the data so that the first embedding ranges from $0$ to $1$, while the second embedding scales from $0$ to the maximum value of the second embedding. The output includes the scaled NLDR data along with the original limits of the embeddings.

```{r, echo=TRUE}
scurve_umap_obj <- gen_scaled_data(nldr_data = scurve_umap)

scurve_umap_obj
```

#### Computing hexagon grid configurations

The configurations of a hexagonal grid are determined by the number of bins and the bin width in each direction. The function `calc_bins_y()` is used for this purpose. This function accepts an object containing scaled NLDR data in the first and second columns, along with numeric vectors that represent the limits of the original NLDR data, the number of bins along the x-axis (`b1`), and the buffer amount as a proportion (`q`).

```{r, echo=TRUE}
bin_configs <- calc_bins_y(
  nldr_obj = scurve_umap_obj, 
  b1 = 15, 
  q = 0.1)

bin_configs
```

#### Binning the data

Points are allocated to bins based on the nearest centroid. The hexagonal binning algorithm can be executed using the `hex_binning()` function, or its components can be run separately for added flexibility. The parameters used within `hex_binning()` include an object containing scaled NLDR data in the first and second columns, along with numeric vectors that represent the limits of the original NLDR data (`nldr_obj`), the number of bins along the x-axis (`b1`), and the buffer amount as a proportion of the data (`q`). The output is an object of the `hex_bin_obj` class, which contains the bin widths in each direction (`a1`, `a2`), the number of bins in each direction (`bins`), the coordinates of the hexagonal grid starting point (`start_point`), the details of bin centroids (`centroids`), the coordinates of bins (`hex_poly`), NLDR components with their corresponding hexagon IDs (`data_hb_id`), hex bins with their corresponding standardized counts (`std_cts`), the total number of bins (`tot_bins`), the number of non-empty bins (`non_bins`), and the points within each hexagon (`pts_bins`).  

```{r, echo=TRUE}
hb_obj <- hex_binning(
  nldr_obj = scurve_umap_obj, 
  b1 = 15, 
  q = 0.1)
```

<!--add each step separately-->
<!--add hexbin notation image-->

```{r}
#| label: code-illustration
# Code to draw illustration for notation
## hexagon binning to have regular hexagons
hb_obj_notation <- hex_binning(
  nldr_obj = scurve_umap_obj, 
  b1 = 9, 
  q = 0.1)

a1_temp <- hb_obj_notation$a1
a2_temp <- hb_obj_notation$a2
l_temp <- quad(a=3, b = 2 * a2_temp, c = -(a2_temp^2 + a1_temp^2))

## Data set with all centroids
all_centroids_df_temp <- hb_obj_notation$centroids
hex_grid_temp <- hb_obj_notation$hex_poly

hex_grid_temp45 <- hex_grid_temp |> 
  filter(h == 45)

start_pt <- all_centroids_df_temp |> 
  filter(h == 1)
d_rect <- tibble(x1min = 0, 
                 x1max = 1,
                 x2min = 0,
                 x2max = diff(scurve_umap_obj$lim2)/diff(scurve_umap_obj$lim1)) # x2max = r2

# To move the rectangle to ignore the overlap with the centroids
# rect_adj <- tibble(x1 = 0.03, x2 = 0.03)
rect_adj <- tibble(x1 = -0.03, x2 = 0.03)


a1 <- tibble(x = all_centroids_df_temp$c_x[4],
             xend = all_centroids_df_temp$c_x[5],
             y = all_centroids_df_temp$c_y[21],
             yend = all_centroids_df_temp$c_y[21],
             label = expression(a[1]))
a2 <- tibble(x = all_centroids_df_temp$c_x[25],
             xend = all_centroids_df_temp$c_x[25],
             y = all_centroids_df_temp$c_y[25],
             yend = all_centroids_df_temp$c_y[33],
             label = expression(a[2]))
l <- tibble(x = hex_grid_temp45$x[2],
            xend = hex_grid_temp45$x[3],
            y = hex_grid_temp45$y[2],
            yend = hex_grid_temp45$y[3],
            label = expression(l))

hex_param_vis <- ggplot() + 
    geom_polygon(data = hex_grid_temp, 
                        aes(x = x, 
                            y = y, 
                            group = h),
                 fill = "white", 
                 color = "#bdbdbd") +
    geom_point(data = all_centroids_df_temp, aes(
      x = c_x, 
      y = c_y), 
      color = "#31a354", size = 0.9) +
    geom_point(data = start_pt, aes(x = c_x, 
                                    y = c_y), 
               color = "black") + 
    geom_rect(data=d_rect, 
              aes(xmin = x1min - rect_adj$x1,# - rect_adj$s1, 
                  xmax = x1max - rect_adj$x1,# - rect_adj$s1, 
                  ymin = x2min - rect_adj$x2,# - rect_adj$s2, 
                  ymax = x2max - rect_adj$x2),# - rect_adj$s2), 
              fill = "white", 
              color = "black", 
              alpha = 0, 
              linewidth = 0.7) +
    geom_point(data=d_rect, aes(x=x1min - rect_adj$x1, 
                                y=x2min - rect_adj$x2)) + 
    geom_point(data=d_rect, aes(x=x1max - rect_adj$x1, 
                                y=x2min - rect_adj$x2)) + 
    geom_point(data=d_rect, aes(x=x1min - rect_adj$x1, 
                                y=x2max - rect_adj$x2)) + 
    annotate("text", x=d_rect$x1min - rect_adj$x1, 
                     y=d_rect$x2min - rect_adj$x2,
                     label = "(0,0)", 
             hjust=-0.1, vjust=-0.3) + 
    annotate("text", x=d_rect$x1max - rect_adj$x1, 
                     y=d_rect$x2min - rect_adj$x2,
                     label = "(0,1)", 
             hjust=1.1, vjust=-0.3) + 
    annotate("text", x=d_rect$x1min - rect_adj$x1, 
                     y=d_rect$x2max - rect_adj$x2,
                     label = expression(group("(", 
                        list(0, y[2][max]),")")), 
            hjust=-0.1, vjust=1.2) + 
    geom_segment(data=d_rect, aes(
      x = x1min  - rect_adj$x1, # 0 - 0.03, 
      y = -0.31, 
      xend = x1max - rect_adj$x1, #1 - 0.03, 
      yend = -0.31), #-0.35),
      arrow = arrow(length = unit(0.03, "npc"),
                               ends = "both"), 
                 color = "black")+
    annotate("text", x=0.5, y=-0.36, 
             label = expression(r[1]), color = "black") +
    geom_segment(data=d_rect, aes(
      x = -0.25, 
      y = x2min - rect_adj$x2, #0 - 0.05, 
      xend = -0.25, 
      yend = x2max - rect_adj$x2), #r2 - 0.05),
      arrow = arrow(length = unit(0.03, "npc"),
                       ends = "both"), 
                 color = "black")+ 
    annotate("text", x=-0.3, y=0.4, 
             label = expression(r[2]), color = "black") +
    geom_segment(data = a1, aes(
      x = x, #-0.1 + 0.2087578, 
      y = y, #-0.15, 
      xend = xend, #-0.1 + 0.2087578*2, 
      yend = yend), #-0.15),
      arrow = arrow(length = unit(0.03, "npc"),
        ends = "both"), 
        color = "black")+ # a1 = 0.2087578
    annotate("text", 
             x=(a1$x+a1$xend)/2, 
             y=a1$y, 
             label = expression(a[1]), 
             color = "black",
             vjust = 1.2) +
    geom_segment(data = a2, aes(
      x = x, #-0.15, 
      y = y, #-0.1*r2 + 0.1807896*2, 
      xend = xend, #-0.15, 
      yend = yend), #-0.1*r2 + 0.1807896*3),
      arrow = arrow(length = unit(0.03, "npc"),
                               ends = "both"), 
      color = "black") + # a2 = 0.1807896
    annotate("text", x=a2$x, y=(a2$y+a2$yend)/2, 
             label = expression(a[2]), 
             color = "black", hjust=-0.2) +
    annotate("text", x=-0.18, y=-0.24, 
      label = expression(group("(", list(s[1], s[2]), ")")),
      color = "black") +
  geom_segment(data = l, aes(
      x = x, #-0.15, 
      y = y, #-0.1*r2 + 0.1807896*2, 
      xend = xend, #-0.15, 
      yend = yend), #-0.1*r2 + 0.1807896*3),
      arrow = arrow(length = unit(0.03, "npc"),
                               ends = "both"), 
      color = "black") + 
    annotate("text", x=l$x + 0.03, y=(l$y+l$yend)/2, 
             label = expression(l), 
             color = "black", hjust=-0.2) +
  coord_equal()
```

```{r hex-param, fig.cap="The components of the hexagon grid illustrating notation.", out.width="50%", fig.align='center', fig.pos='H'}

hex_param_vis
```


If the hexagonal binning process is run separately, it involves several steps: (i) generating all possible centroids in a hexagonal grid, (ii) creating the coordinates of the hexagons, (iii) assigning data points to their respective hexagons, (iv) computing the standardized number of points within each hexagon, and (v) mapping the points to their corresponding hexagonal bins. 

##### Generating all possible centroids in a hexagonal grid

The `gen_centroids()` function calculates the centroids of a hexagonal grid. 

The coordinate limits of the embedding (`lim1` and `lim2`) are used to compute the aspect ratio between the two axes, which informs vertical spacing. The function then calls `calc_bins_y()`, a helper function that determines the appropriate number of hexagonal rows (`bin2`) and the width of each hexagon (`a1`) given the specified number of bins along the x-axis (`b1`) and buffer (`q`).

Then, the centroids are computed iteratively. The x-coordinates for centroids in odd-numbered rows are initialized as a sequence spaced by the hexagon width. Even-numbered rows are staggered by half this width to achieve a hexagonal tiling effect. Vertical spacing (`a2`) is derived by $\sqrt{3}/2 \times a_1$.

The y-coordinates for each row are similarly calculated, and paired with the x-coordinates based on whether the total number of rows is even or odd. In the case of an odd number of rows, the final row uses only the odd-row x-coordinates to maintain the alternating pattern.

Finally, a tibble is returned containing a unique hexagon ID (`h`) along with the corresponding x and y centroid coordinates (`c_x`, `c_y`), which define the layout of the hexagonal grid over the $2\text{-}D$ space.

```{r, echo=TRUE}
all_centroids_df <- gen_centroids(
  nldr_obj = scurve_umap_obj, 
  b1 = 15, 
  q = 0.1
  )

all_centroids_df
```

##### Creating the coordinates of the hexagons

Following the generation of hexagonal centroids, the `gen_hex_coord()` function constructs the coordinates of each hexagonal bin by defining its six polygonal vertices. These coordinates are used to visualize the hexagonal tessellation.

Each hexagon is defined relative to its centroid $(C_x, C_y)$, with six vertices positioned equidistantly around the center. The function first verifies the presence of the required hexagon width parameter `a1`. This width determines the horizontal spacing.

Two derived constants are calculated to define the relative distances to the vertices. The horizontal and vertical offset is defined as $dx = a_1/2$, and $dy = a_1/\sqrt{3}$ repectively. A vertical spacing factor $v = a_1/2\sqrt{3}$ refines vertical placement in staggered rows.

With these values, the function determines fixed offsets in the x and y directions for all six vertices relative to the centroid. These offsets form two vectors (`x_add_factor` and `y_add_factor`) corresponding to the six compass directions used to define the polygon shape: top, top-left, bottom-left, bottom, bottom-right, and top-right.

For each centroid, six vertices are computed and assigned a polygon ID (`h`) corresponding to the centroid’s `h`. These points are aggregated into a tibble that includes the polygon ID (`h`) and the respective x (`x`) and y (`y`) coordinates for all hexagon corners.

To reduce computational overhead, the geometry calculations are implemented in C++ using `gen_hex_coord_cpp()`, which returns a `data.frame` of vertex coordinates.

```{r, echo=TRUE}
all_hex_coord <- gen_hex_coord(
  centroids_data = all_centroids_df, 
  a1 = bin_configs$a1
  )

head(all_hex_coord, 5)
```

##### Assigning data points to their respective hexagons

After generating the centroids that define the hexagonal grid, the next step is to assign each point in the NLDR embedding to its nearest hexagonal bin. The `assign_data()` function performs this assignment by calculating the $2\text{-}D$ Euclidean distance between each point in the $2\text{-}D$ embedding and all hexagon centroids.

First, the function extracts the first two dimensions of the scaled NLDR embedding, which represent the $2\text{-}D$ layout. It then selects the corresponding x and y coordinates of each hexagon’s centroid.

Both the embedding coordinates and the centroid coordinates are converted to matrices to facilitate distance computations. The function uses the `proxy::dist()` method to compute a pairwise Euclidean distance matrix between all NLDR points and all centroids. For each NLDR point, the function identifies the index of the centroid with the smallest distance representing the closest hexagon—and assigns the corresponding hexagon ID (`h`) to the point.

The result is a data frame of the scaled $2\text{-}D$ embedding with an additional `h` column, indicating the hexagonal bin to which each point belongs. 

```{r, echo=TRUE}
umap_hex_id <- assign_data(
  nldr_obj = scurve_umap_obj, 
  centroids_data = all_centroids_df
  )

head(umap_hex_id, 5)
```

##### Computing the standardized number of points within each hexagon

The `compute_std_counts()` function calculates both the raw and standardized counts for each hexagon.

The function begins by grouping the data by `h` and counting the number of NLDR points falling within each bin. These raw counts are stored as `n_h`. To enable comparisons across bins with varying densities, the function then standardizes these counts by dividing each bin’s count by the maximum count across all bins. This yields a normalized metric, `w_h`, ranging from 0 to 1.

```{r, echo=TRUE}
std_df <- compute_std_counts(
  scaled_nldr_h = umap_hex_id
  )

head(std_df, 5)
```

##### Mapping the points to their corresponding hexagonal bins

The `find_pts()` function extracts the list of data point identifiers (`ID`) assigned to each hexagon in the NLDR space.

The function first groups the input data by `h`, which represents the hexagon label associated with each point in the $2\text{-}D$ layout. Within each group, it collects the `ID`s into a list, resulting in a summary data frame where each row corresponds to a single hexagon. The resulting column, `pts_list`, contains all point identifiers associated with that hexagon. 

```{r, echo=TRUE}
pts_df <- find_pts(
  scaled_nldr_hexid = umap_hex_id
  )

head(pts_df, 5)
```

#### Obtaining bin centroids

The `extract_hexbin_centroids()` function combines hexagonal bin coordinates, raw and standardized counts within each hexagons.

This function begins by arranging the `counts_data` by `h` to ensure consistent ordering. It then performs a full join with `centroids_data`, aligning hexagon IDs between the two datasets to incorporate both hexagonal bin centroids and count metrics. After merging, the function handles missing values in the count columns: any `NA` values in `w_h` or `n_h` are replaced with zeros. This ensures that hexagons with no assigned data points are retained in the output, with zero values for count-related fields. The resulting data frame contains the full set of hexagon centroids along with associated bin counts and standardized counts.

```{r, echo=TRUE}
df_bin_centroids <- extract_hexbin_centroids(
  centroids_data = all_centroids_df, 
  counts_data = hb_obj$std_cts
  )

head(df_bin_centroids, 5)
```

#### Indicating neighbors by line segments connecting centroids

To represent the neighborhood structure of hexagonal bins in a $2\text{-}D$ layout, we employ Delaunay triangulation on the centroids of hexagons. This geometric approach is used to infer which bins are considered neighbors.

The `tri_bin_centroids()` function generates a triangulation object from the x and y coordinates of hexagon centroids using the `tripack::tri.mesh()` function. This triangulation forms the structural basis for identifying adjacent bins.

```{r, echo=TRUE}
tr_object <- tri_bin_centroids(
  centroids_data = df_bin_centroids
  )
```

The `gen_edges()` function uses this triangulation object to extract line segments between neighboring bins. It constructs a unique set of bin-to-bin connections by identifying the triangle edges and filtering duplicate or reversed links. Each edge is then annotated with its start and end coordinates, and a Euclidean distance is computed using the helper function `calc_2d_dist()`. Only edges within a hexagon’s neighborhood radius (based on the hexagon side length `a1`) are retained.

```{r, echo=TRUE}
trimesh <- gen_edges(tri_object = tr_object, a1 = hb_obj$a1)

head(trimesh, 5)
```

The `update_trimesh_index()` function re-indexes the node IDs to ensure that edge identifiers are sequentially numbered and consistent with downstream analysis.

```{r, echo=TRUE}
trimesh <- update_trimesh_index(trimesh_data = trimesh)

head(trimesh, 5)
```

#### Identifying and removing low-density hexagons

Not all hexagons contain meaningful information. Some may have very few or no data points due to the sparsity or shape of the underlying structure. Simply removing hexagons with low counts (e.g., fewer than a fixed threshold) can lead to gaps or "holes" in the $2\text{-}D$ structure, potentially disrupting the continuity of the representation.

To address this, we propose a more nuanced method that evaluates each hexagon not only based on its own density, but also in the context of its immediate neighbors. The `find_low_dens_hex()` function identifies hexagonal bins with insufficient local support by calculating the average standardized count across their six neighboring bins. If this mean neighborhood density is below a user-defined threshold (e.g., 0.05), the hexagon is flagged for removal.

The `find_low_dens_hex()` function identifies hexagons with low point densities, considering the densities of their neighboring bins as well. The `find_low_dens_hex()` function relies on a helper, `compute_mean_density_hex()`, which iterates over all hexagons and computes the average density across neighbors based on their `h` and a defined number of bins along the x-axis (`b1`). The hexagonal layout assumes a fixed grid structure, so neighbor IDs are computed by positional offsets.

```{r, echo=TRUE}
find_low_dens_hex(
  model_2d = df_bin_centroids, 
  b1 = 15, 
  benchmark_mean_dens = 0.05
)

```

For simplicity, we remove low-density hexagons using a threshold of $10$.

```{r, echo=TRUE}
df_bin_centroids <- df_bin_centroids |>
  dplyr::filter(n_h > 1)

trimesh <- trimesh |>
  dplyr::filter(from_count > 1,
                to_count > 1)

trimesh <- update_trimesh_index(trimesh)

```

### Lifting the model into high dimensions

The final step involves lifting the fitted $2\text{-}D$ model into $p\text{-}D$ by computing the $p\text{-}D$ mean of data points within each hexagonal bin to represent bin centroids. This transformation is performed using the `avg_highd_data()` function, which takes $p\text{-}D$ data (`highd_data`) and embedding data with their corresponding hexagonal bin IDs as inputs (`scaled_nldr_hexid`).

```{r, echo=TRUE}
df_bin <- avg_highd_data(
  highd_data = scurve, 
  scaled_nldr_hexid = hb_obj$data_hb_id
)

head(df_bin, 5)
```

### Prediction

The `predict_emb()` function is used to predict $2\text{-}D$ embedding for a new $p\text{-}D$ data point using the fitted model. This function is useful to predict $2\text{-}D$ embedding irrespective of the NLDR technique.

In the prediction process, first, the nearest $p\text{-}D$ model point is identified for a given new $p\text{-}D$ data point by computing $p\text{-}D$ Euclidean distance. Then, the corresponding $2\text{-}D$ bin centroid mapping for the identified $p\text{-}D$ model point is determined. Finally, the coordinates of the identified $2\text{-}D$ bin centroid is used as the predicted NLDR embedding for the new $p\text{-}D$ data point. 

To accelerate this process, the nearest-neighbor search is implemented in C++ using `Rcpp` via the internal function `compute_highd_dist()`.

```{r, echo=TRUE}
predict_data <- predict_emb(
  highd_data = scurve, 
  model_2d = df_bin_centroids, 
  model_highd = df_bin
  )

head(predict_data, 5)
```

### Compute residuals and Root Mean Square Error (RMSE)

As a Goodness of fit statistics for the model, `glance()` is used to compute residuals and RMSE. These metrics are used to assess how well the fitted model will capture the underlying structure of the $p\text{-}D$ data. 

This function begins by renaming the columns of the input `model_highd` data frame to avoid naming conflicts during subsequent joins. It then uses the `predict_emb()` function to assign each point in the high-dimensional dataset to a corresponding bin in the 2D model, producing a prediction data frame that contains both the predicted bin assignment (`pred_hb_id`) and the original observation `ID`.

The function joins this prediction output with both the high-dimensional model (to get mean bin coordinates in the original space) and the original high-dimensional data (to retrieve true coordinates). It then calculates squared differences between the true and predicted high-dimensional coordinates for each dimension, storing these as `error_square_x1`, `error_square_x2`, ..., up to the dimensionality of the data.

From these per-dimension errors, the function computes absolute error which is the sum of absolute differences across all dimensions and observations and the RMSE which is the average of the total squared error per point.

These metrics are returned in a tibble as `Error` (absolute error) and `RMSE` (root mean squared error). The computation of total absolute error and RMSE is performed in C++ for efficiency using the internal `compute_errors()` function.

```{r, echo=TRUE}
glance(
  highd_data = scurve, 
  model_2d = df_bin_centroids, 
  model_highd = df_bin
  )
```

Furthermore, `augment()` accepts $2\text{-}D$ and $p\text{-}D$ model points, and the $p\text{-}D$ data and adds information about each observation in the data set. 

The function starts by renaming columns in the `model_highd` data frame to avoid conflicts. It then predicts the high-dimensional bin assignments for each point using the `predict_emb()` function, mapping each observation to its nearest $2\text{-}D$ bin (`pred_hb_id`). This prediction is joined with the mean high-dimensional coordinates of each bin from the model and with the original high-dimensional data.

Next, the function computes residuals between each original coordinate (`x1`, `x2`, ..., `xp`) and the corresponding modeled coordinate (`model_high_d_x1`, ..., `model_high_d_xp`) across all dimensions. It calculates both squared errors and absolute errors per dimension. These are used to compute two aggregate diagnostic measures per point. First, the `row_wise_total_error` which is the total squared error across all dimensions, and the `row_wise_abs_error` which is the total absolute error across all dimensions.

The final output is a data frame that combines the original IDs, high-dimensional coordinates, predicted bin IDs, modeled coordinates, residuals, row wise total error, absolute error for the fitted values, and row wise total absolute error for each observation. The augmented dataset is always returned as a `tibble::tibble` with the same number of rows as the passed dataset.

```{r, echo=TRUE}
model_error <- augment(
  highd_data = scurve, 
  model_2d = df_bin_centroids, 
  model_highd = df_bin
  )

head(model_error, 5)
```

### Visualizations

The package offers several $2\text{-}D$ visualizations, including:

- A full hexagonal grid,
- A hexagonal grid that matches the data,
- A full grid based on centroid triangulation,
- A centroid triangulation grid that aligns with the data, 
- A triangular mesh for any provided set of points.

The generated $p\text{-}D$ model, overlaid with the data, can also be visualized using `show_langevitour`. Additionally, it features a function for visualizing the $2\text{-}D$ projection of the fitted model overlaid on the data, called `plot_proj`. 

Furthermore, there are two interactive plots, `show_link_plots` and `show_error_link_plots`, which are designed to help diagnose the model.

Each visualization can be generated using its respective function, as described in this section.

#### Hexagonal grid

The `geom_hexgrid()` function introduces a custom `ggplot2` layer designed for visualizing hexagonal grid on a provided set of bin centroids.

To display the complete grid, users should supply all available bin centroids. 

```{r, echo=TRUE}
full_hexgrid <- ggplot() + 
  geom_hexgrid(
    data = hb_obj$centroids, 
    aes(x = c_x, y = c_y)
    ) 
```

If the goal is to plot only the subset of hexagons that correspond to bins containing data points, then only the centroids associated with those bins should be passed.

```{r, echo=TRUE}
data_hexgrid <- ggplot() + 
  geom_hexgrid(
    data = df_bin_centroids, 
    aes(x = c_x, y = c_y)
    ) 
```

#### Triangular mesh

The `geom_trimesh()` function introduces a custom `ggplot2` layer designed for visualizing $2\text{-}D$ wireframe on a provided set of bin centroids.

To display the complete wireframe, users should supply all available bin centroids. 

```{r, echo=TRUE}
full_triangulation_grid <- ggplot() + 
  geom_trimesh(
    data = hb_obj$centroids, 
    aes(x = c_x, y = c_y)
    ) 
```

If the goal is to plot only the subset of hexagons that correspond to bins containing data points, then only the centroids associated with those bins should be passed.

```{r, echo=TRUE}
data_triangulation_grid <- ggplot() + 
  geom_trimesh(
    data = df_bin_centroids, 
    aes(x = c_x, y = c_y)
    ) 
```

```{r geom-outputs, fig.cap="The outputs of `geom_hexgrid` and `geom_trimesh` include: (a) a complete hexagonal grid, (b) a hexagonal grid that corresponds with the data, (c) a full grid based on centroid triangulation, and (d) a centroid triangulation grid that aligns with the data.", fig.align='center', fig.pos='H', fig.height=5, fig.width=20, eval=knitr::is_html_output()}

full_hexgrid + data_hexgrid + 
  full_triangulation_grid + data_triangulation_grid +
  plot_layout(ncol = 4)
```

```{r geom-outputs-pdf, fig.cap="The outputs of `geom\\_hexgrid` and `geom\\_trimesh` include: (a) a complete hexagonal grid, (b) a hexagonal grid that corresponds with the data, (c) a full grid based on centroid triangulation, and (d) a centroid triangulation grid that aligns with the data.", fig.align='center', fig.pos='H', fig.height=5, fig.width=20, eval=knitr::is_latex_output()}

full_hexgrid + data_hexgrid + 
  full_triangulation_grid + data_triangulation_grid +
  plot_layout(ncol = 4)
```

#### $p\text{-}D$ model visualization

To evaluate how well the $p\text{-}D$ model captures the underlying structure of the high-dimensional data, we provide a visualization using the `show_langevitour()` function. This function renders a dynamic projection of both the high-dimensional data and the model using the `langevitour` package.

Before plotting, the data needs to be organized into a combined format through the `comb_data_model()` function. This function takes three inputs: `highd_data` (the high-dimensional observations), `model_highd` (high-dimensional summaries for each bin), and `model_2d` (the hexagonal bin centroids of the model). It returns a tidy data frame combining both the data and the model.

In this structure, the `type` variable distinguishes between original observations (`"data"`) and the bin-averaged model representation (`"model"`).

```{r, echo=TRUE}
df_exe <- comb_data_model(
  highd_data = scurve, 
  model_highd = df_bin, 
  model_2d = df_bin_centroids
  )
```

The `show_langevitour()` function then renders the visualization using the `langevitour` interface, displaying both types of points in a dynamic tour. The `edge_data` input defines connections between neighboring bins (i.e., the hexagonal edges) to visualize the model’s structure.

In the resulting interactive visualization black points represent the high-dimensional data, green points represent the model centroids from each bin, and the lines between model points reflect the $2\text{-}D$ wireframe structure mapped back to high-dimensional space.

```{r, echo=TRUE, eval=knitr::is_html_output(), fig.pos='H', fig.cap="`langevitour` output of the lifted high-dimensional wireframe model from the `Scurve` UMAP layout. These views illustrate how the lifted wireframe model captures the structure of the `Scurve` data. The two twists visible in the UMAP layout can also be seen in the lifted model."}

show_langevitour(
  point_data = df_exe, 
  edge_data = trimesh
  )
```

```{r, eval=knitr::is_latex_output(), fig.pos='H', fig.cap="$2\\text{-}D$ projections of the lifted high-dimensional wireframe model from the `Scurve` UMAP layout. Each panel (a1–a4) shows the model (black) overlaid on `Scurve` data (in purple) in different projections. These views illustrate how the lifted wireframe model captures the structure of the `Scurve` data. The two twists visible in the UMAP layout can also be seen in the lifted model."}

scurve_proj_umap_model1 + scurve_proj_umap_model2 + 
  scurve_proj_umap_model3 + scurve_proj_umap_model4 + 
  plot_layout(ncol = 4)
```

#### Link plots

There are mainly two interactive link plots can be generated. 

To support interactive evaluation of how well the $p\text{-}D$ model captures the structure of the high-dimensional data, we introduce `show_link_plots()`. This visualization combines two complementary views: the nonlinear dimension reduction (NLDR) representation and a dynamic tour of the model ovelaid the data in the high-dimensional space. Both views are interactively linked, enabling users to explore.

Before visualization, the input data must be prepared using the `comb_all_data_model()` function. This function combines the high-dimensional data (`highd_data`), the NLDR data (`nldr_data`), and the bin-averaged high-dimensional model representation (`model_highd`) aligned to the $2\text{-}D$ bin layout (`model_2d`):

This combined dataset includes both the original observations and the bin-level model averages, labeled with a `type` variable for distinguishing between them.

```{r, echo=TRUE}
df_exe <- comb_all_data_model(
  highd_data = scurve, 
  nldr_data = scurve_umap, 
  model_highd = df_bin, 
  model_2d = df_bin_centroids
  )
```

The function `show_link_plots()` generates two side-by-side, interactively linked plots; a $2\text{-}D$ NLDR representation, and a dynamic projection tour in the original high-dimensional space (using the `langevitour` package), displaying both the data and the model. The function takes the output from `comb_all_data_model()` (`point_data`) and `edge_data` which defines connections between neighboring bins.

These two views are linked using `crosstalk`, allowing interactive selection of points in the NLDR plot to highlight corresponding structures in the `langevitour` output. 

```{r linkerror, echo=TRUE, eval=knitr::is_html_output(), fig.cap="Link plot showing the relationship between the NLDR layout (left) and the fitted model overlaid with the data in $7\\text{-}D$ (right)."}

nldrdt_link <- show_link_plots(
  point_data = df_exe, 
  edge_data = trimesh, 
  point_colour = clr_choice
  )

class(nldrdt_link) <- c(class(nldrdt_link), "htmlwidget")

nldrdt_link
```

```{r}
## Create the first row of selection
scurve_umap_scaled_select1 <- scurve_umap_scaled |>
  mutate(select_area = if_else(emb1 <= 0.7 & emb1 >= 0.4 & emb2 <= 0.25 & emb2 >= 0, "selected", "deselected"))

scurve_umap_scaled_select1_selected <- scurve_umap_scaled_select1 |>
  filter(select_area == "selected")

scurve_umap_scaled_select1_deselected <- scurve_umap_scaled_select1 |>
  filter(select_area == "deselected")

scurve_umap_plt_select1 <- ggplot(
  scurve_umap_scaled_select1_deselected, 
  aes(x = emb1, y = emb2)) +
  geom_point(alpha = 0.5, color = clr_choice, size = 0.5) +
  geom_point(data = scurve_umap_scaled_select1_selected, aes(x = emb1, y = emb2), alpha = 0.5, color = "#756bb1", size = 0.5) +
  xlim(sc_xlims) +
  ylim(sc_ylims)

scurve_umap_plt_select1_lk <- scurve_umap_plt_select1 +
  interior_annotation("a1")

scurve_umap_plt_select1_lk2 <- scurve_umap_plt_select1 +
  interior_annotation("a2") 

proj_obj2[["cluster"]] <- factor(scurve_umap_scaled_select1$select_area,
                                 levels=c("deselected", "selected"))

projected_df <- proj_obj2$projected_df
model_df <- proj_obj2$model_df
axes <- proj_obj2$axes
circle <- proj_obj2$circle

projected_df <- projected_df |>
  dplyr::mutate(cluster = proj_obj2$cluster)

scurve_proj_umap_model1_selected1 <- ggplot() +
      geom_point(
        data = projected_df,
        aes(
          x = proj1,
          y = proj2,
          colour = factor(cluster, levels = c("deselected", "selected")),
          size = factor(cluster, levels = c("deselected", "selected"))),
        alpha = 0.5) +
      geom_segment(
        data = model_df,
        aes(
          x = proj1_from,
          y = proj2_from,
          xend = proj1_to,
          yend = proj2_to),
        colour = "#000000",
        linewidth = 0.8,
        alpha = 0.4) +
      geom_segment(
          data=axes,
          aes(x=x1, y=y1, xend=x2, yend=y2),
          colour="grey70") +
        geom_text(
          data=axes,
          aes(x=x2, y=y2),
          label=rownames(axes),
          colour="grey50",
          size = 2.5) +
        geom_path(
          data=circle,
          aes(x=c1, y=c2), colour="grey70") +
        xlim(c(-0.35, 0.35)) +
        ylim(c(-0.35, 0.35)) +
  interior_annotation(label = "a2", cex = 1) +
  scale_color_manual(values = c(clr_choice, '#756bb1')) +
  scale_size_manual(values = c('deselected' = 1.0, 'selected' = 1.5)) +
  theme(aspect.ratio = 1,
        legend.position = "none")

scurve_proj_umap_model1_selected1_dp <- ggplot() +
      geom_point(
        data = projected_df,
        aes(
          x = proj1,
          y = proj2,
          colour = factor(cluster, levels = c("deselected", "selected")),
          size = factor(cluster, levels = c("deselected", "selected"))),
        alpha = 0.5) +
      geom_segment(
        data = model_df,
        aes(
          x = proj1_from,
          y = proj2_from,
          xend = proj1_to,
          yend = proj2_to),
        colour = "#000000",
        linewidth = 0.8,
        alpha = 0.4) +
      geom_segment(
          data=axes,
          aes(x=x1, y=y1, xend=x2, yend=y2),
          colour="grey70") +
        geom_text(
          data=axes,
          aes(x=x2, y=y2),
          label=rownames(axes),
          colour="grey50",
          size = 2) +
        geom_path(
          data=circle,
          aes(x=c1, y=c2), colour="grey70") +
        xlim(c(-0.35, 0.35)) +
        ylim(c(-0.35, 0.35)) +
  interior_annotation(label = "a3", cex = 1) +
  scale_color_manual(values = c(clr_choice, '#756bb1')) +
  scale_size_manual(values = c('deselected' = 1.0, 'selected' = 1.5)) +
  theme(aspect.ratio = 1,
        legend.position = "none")

## Create the second row of selection
scurve_umap_scaled_select2 <- scurve_umap_scaled |>
  mutate(select_area = if_else(emb1 <= 0.55 & emb1 >= 0.25 & emb2 <= 1.25 & emb2 >= 0.75, "selected", "deselected"))

scurve_umap_scaled_select2_selected <- scurve_umap_scaled_select2 |>
  filter(select_area == "selected")

scurve_umap_scaled_select2_deselected <- scurve_umap_scaled_select2 |>
  filter(select_area == "deselected")

scurve_umap_plt_select2 <- ggplot(
  scurve_umap_scaled_select2_deselected, 
  aes(x = emb1, y = emb2)) +
  geom_point(alpha = 0.5, color = clr_choice, size = 0.5) +
  geom_point(data = scurve_umap_scaled_select2_selected, aes(x = emb1, y = emb2), alpha = 0.5, color = "#756bb1", size = 0.5) +
  xlim(sc_xlims) +
  ylim(sc_ylims)

scurve_umap_plt_select2_lk <- scurve_umap_plt_select2 +
    interior_annotation("b1") 

scurve_umap_plt_select2_lk2 <- scurve_umap_plt_select2 +
    interior_annotation("b2") 

proj_obj2[["cluster"]] <- factor(scurve_umap_scaled_select2$select_area,
                                 levels=c("deselected", "selected"))

projected_df <- proj_obj2$projected_df
model_df <- proj_obj2$model_df
axes <- proj_obj2$axes
circle <- proj_obj2$circle

projected_df <- projected_df |>
  dplyr::mutate(cluster = proj_obj2$cluster)

scurve_proj_umap_model1_selected2 <- ggplot() +
      geom_point(
        data = projected_df,
        aes(
          x = proj1,
          y = proj2,
          colour = factor(cluster, levels = c("deselected", "selected")),
          size = factor(cluster, levels = c("deselected", "selected"))),
        alpha = 0.5) +
      geom_segment(
        data = model_df,
        aes(
          x = proj1_from,
          y = proj2_from,
          xend = proj1_to,
          yend = proj2_to),
        colour = "#000000",
        linewidth = 0.8,
        alpha = 0.4) +
      geom_segment(
          data=axes,
          aes(x=x1, y=y1, xend=x2, yend=y2),
          colour="grey70") +
        geom_text(
          data=axes,
          aes(x=x2, y=y2),
          label=rownames(axes),
          colour="grey50",
          size = 2.5) +
        geom_path(
          data=circle,
          aes(x=c1, y=c2), colour="grey70") +
        xlim(c(-0.35, 0.35)) +
        ylim(c(-0.35, 0.35)) +
  interior_annotation(label = "b2", cex = 1) +
  scale_color_manual(values = c(clr_choice, '#756bb1')) +
  scale_size_manual(values = c('deselected' = 1.0, 'selected' = 1.5)) +
  theme(aspect.ratio = 1,
        legend.position = "none")

scurve_proj_umap_model1_selected2_dp <- ggplot() +
      geom_point(
        data = projected_df,
        aes(
          x = proj1,
          y = proj2,
          colour = factor(cluster, levels = c("deselected", "selected")),
          size = factor(cluster, levels = c("deselected", "selected"))),
        alpha = 0.5) +
      geom_segment(
        data = model_df,
        aes(
          x = proj1_from,
          y = proj2_from,
          xend = proj1_to,
          yend = proj2_to),
        colour = "#000000",
        linewidth = 0.8,
        alpha = 0.4) +
      geom_segment(
          data=axes,
          aes(x=x1, y=y1, xend=x2, yend=y2),
          colour="grey70") +
        geom_text(
          data=axes,
          aes(x=x2, y=y2),
          label=rownames(axes),
          colour="grey50",
          size = 2) +
        geom_path(
          data=circle,
          aes(x=c1, y=c2), colour="grey70") +
        xlim(c(-0.35, 0.35)) +
        ylim(c(-0.35, 0.35)) +
  interior_annotation(label = "b3", cex = 1) +
  scale_color_manual(values = c(clr_choice, '#756bb1')) +
  scale_size_manual(values = c('deselected' = 1.0, 'selected' = 1.5)) +
  theme(aspect.ratio = 1,
        legend.position = "none")
```

```{r, eval=knitr::is_latex_output(), fig.pos='H', fig.cap="Exploring the correspondence between UMAP layout and `Scurve` structure in $7\\text{-}D$. Two sets of plots are linked: UMAP layout (a1, b1) and projection of $7\\text{-}D$ model and data (a2, b2). The purple points indicate the selected subsets, which differ between rows. In (a1), the lower bridge of the `Scurve` is highlighted, which corresponds in (a2) to points spanning across both arms of the high-dimensional structure. In (b1), a different region near the upper arm of the `Scurve` is selected, and in (b2) these points map onto one side of the curved manifold in $7\\text{-}D$ projection. While the UMAP layout suggests distinct local clusters, the linked tour views reveal how these selections trace continuous structures in the $7\\text{-}D$ space, highlighting distortions introduced by UMAP."}

scurve_umap_plt_select1_lk + scurve_proj_umap_model1_selected1 +
  scurve_umap_plt_select2_lk + scurve_proj_umap_model1_selected2 +
  plot_layout(ncol = 2)
```

`show_error_link_plots()` helps to see investigate whether the model fits the points everywhere or fits better in some places, or simply mismatches the pattern. 

Before visualization, the input data must be prepared using the `comb_all_data_model_error()` function. The function requires several arguments: points data which contain high-dimensional data (`highd_data`), NLDR data (`nldr_data`), high-dimensional model data (`model_highd`), $2\text{-}D$ model data (`model_2d`), and model error (`error_data`).

This combined dataset includes both the original observations and the bin-level model averages, labeled with a `type` variable for distinguishing between them.

```{r, echo=TRUE}
df_exe <- comb_all_data_model_error(
  highd_data = scurve, 
  nldr_data = scurve_umap, 
  model_highd = df_bin, 
  model_2d = df_bin_centroids, 
  error_data = model_error
  )
```

The function `show_error_link_plots()` generates three side-by-side, interactively linked plots; a error distribution, a $2\text{-}D$ NLDR representation, and a dynamic projection tour in the original high-dimensional space (using the `langevitour` package), displaying both the data and the model. The function takes the output from `comb_all_data_model_error()` (`point_data`) and `edge_data` which defines connections between neighboring bins.

These two views are linked using `crosstalk`, allowing interactive selection of points in the NLDR plot to highlight corresponding structures in the high-dimensional projection. This setup facilitates the diagnosis of local distortion, structural artifacts, and model fit quality.

These three views are linked using `crosstalk`, allowing interactive selection of points in error plot and the NLDR plot to highlight corresponding structures in the `langevitour` output. 

```{r, echo=TRUE, eval=knitr::is_html_output(), fig.cap="Link plot showing the relationship between the distribution of residuals (left), NLDR layout (middle) and the fitted model overlaid with the data in $7\\text{-}D$ (right)."}

errornldrdt_link <- show_error_link_plots(
  point_data = df_exe, 
  edge_data = trimesh, 
  point_colour = clr_choice
)

class(errornldrdt_link) <- c(class(errornldrdt_link), "htmlwidget")

errornldrdt_link
```

```{r}
model_error <- model_error |>
  bind_cols(scurve_umap_scaled |>
              select(-ID))

model_error <- model_error |>
  mutate(sqrt_row_wise_total_error = sqrt(row_wise_total_error))

# Compute density
density_data <- density(model_error$sqrt_row_wise_total_error)
density_df <- data.frame(x = density_data$x, y = density_data$y)

# Add density values to the original dataset
model_error <- model_error |>
  mutate(density = approx(density_df$x, density_df$y, xout = sqrt_row_wise_total_error)$y)

## Create the first row of selection
model_error_select1 <- model_error |>
  mutate(select_area = if_else(emb1 <= 0.7 & emb1 >= 0.4 & emb2 <= 0.25 & emb2 >= 0, "selected", "deselected"))

model_error_select1_selected <- model_error_select1 |>
  filter(select_area == "selected")

model_error_select1_deselected <- model_error_select1 |>
  filter(select_area == "deselected")

error_plot_scurve_hist1 <- ggplot(model_error_select1_deselected, 
      aes(x = sqrt_row_wise_total_error, 
          y = density)) +
  geom_point(alpha=0.7, colour = "#d9d9d9") +
  geom_point(data = model_error_select1_selected, 
      aes(x = sqrt_row_wise_total_error, 
          y = density),
      alpha=0.7, colour = "#756bb1", size = 3) +
  xlab(paste("residual")) +
  ylab("") +
  interior_annotation("a1") +
  theme_bw() +
  theme(axis.ticks.y = element_blank(),
        axis.text.y = element_blank(),
        aspect.ratio = 1)

## Create the second row of selection
model_error_select2 <- model_error |>
  mutate(select_area = if_else(emb1 <= 0.55 & emb1 >= 0.25 & emb2 <= 1.25 & emb2 >= 0.75, "selected", "deselected"))

model_error_select2_selected <- model_error_select2 |>
  filter(select_area == "selected")

model_error_select2_deselected <- model_error_select2 |>
  filter(select_area == "deselected")

error_plot_scurve_hist2 <- ggplot(model_error_select2_deselected, 
      aes(x = sqrt_row_wise_total_error, 
          y = density)) +
  geom_point(alpha=0.7, colour = "#d9d9d9") +
  geom_point(data = model_error_select2_selected, 
      aes(x = sqrt_row_wise_total_error, 
          y = density),
      alpha=0.7, colour = "#756bb1", size = 3) +
  xlab(paste("residual")) +
  ylab("") +
  interior_annotation("b1") +
  theme_bw() +
  theme(axis.ticks.y = element_blank(),
        axis.text.y = element_blank(),
        aspect.ratio = 1)
```

```{r, eval=knitr::is_latex_output(), fig.pos="H", fig.cap="Exploring residuals in relation to UMAP layouts using a $7\\text{-}D$ `Scurve` model. Three views are linked: distribution of residuals (a1, b1), UMAP layout (a2, b2), and projection of the $7\\text{-}D$ model with data (a3, b3). The purple points highlight selected subsets of the data, which differ across rows. In the top row (a1–a3), points with higher residuals (a1) are selected, corresponding to the sparse bridging region in the UMAP layout (a2) and the less dense end of the `Scurve` in the high-dimensional projection (a3). In the bottom row (b1–b3), points with lower residuals (b1) are highlighted, which map to one side of the dense region in the NLDR layout (b2) and to a thicker band of the `Scurve` in the projection (b3). This comparison illustrates how residuals can help diagnose distortions in UMAP, with high-residual points often concentrated in sparse or stretched regions of the structure."}

error_plot_scurve_hist1 + scurve_umap_plt_select1_lk2 + scurve_proj_umap_model1_selected1_dp +
  error_plot_scurve_hist2 + scurve_umap_plt_select2_lk2 + scurve_proj_umap_model1_selected2_dp +
  plot_layout(ncol = 3)
```

<!-- # Find the most appropriate fit -->

<!-- ```{r} -->
<!-- #| label: scurve-diff-umap-layouts -->

<!-- nldr_scaled_obj <- gen_scaled_data( -->
<!--   nldr_data = scurve_umap) -->
<!-- umap_scaled1 <- nldr_scaled_obj$scaled_nldr -->

<!-- scurve_nldr1 <- umap_scaled1 |> -->
<!--   ggplot(aes(x = emb1, -->
<!--              y = emb2))+ -->
<!--   geom_point(alpha=0.1, size=1, colour='#e41a1c') + -->
<!--   interior_annotation("a", c(0.08, 0.9)) -->

<!-- nldr_scaled_obj2 <- gen_scaled_data( -->
<!--   nldr_data = scurve_umap2) -->
<!-- umap_scaled2 <- nldr_scaled_obj2$scaled_nldr -->

<!-- scurve_nldr2 <- umap_scaled2 |> -->
<!--   ggplot(aes(x = emb1, -->
<!--              y = emb2))+ -->
<!--   geom_point(alpha=0.1, size=1, colour='#ff7f00') + -->
<!--   interior_annotation("b") -->

<!-- nldr_scaled_obj3 <- gen_scaled_data( -->
<!--   nldr_data = scurve_umap3) -->
<!-- umap_scaled3 <- nldr_scaled_obj3$scaled_nldr -->

<!-- scurve_nldr3 <- umap_scaled3 |> -->
<!--   ggplot(aes(x = emb1, -->
<!--              y = emb2))+ -->
<!--   geom_point(alpha=0.1, size=1, colour='#4daf4a') + -->
<!--   interior_annotation("c", c(0.08, 0.9)) -->

<!-- nldr_scaled_obj4 <- gen_scaled_data( -->
<!--   nldr_data = scurve_umap4) -->
<!-- umap_scaled4 <- nldr_scaled_obj4$scaled_nldr -->

<!-- scurve_nldr4 <- umap_scaled4 |> -->
<!--   ggplot(aes(x = emb1, -->
<!--              y = emb2))+ -->
<!--   geom_point(alpha=0.1, size=1, colour='#a65628') + -->
<!--   interior_annotation("d") -->

<!-- nldr_scaled_obj5 <- gen_scaled_data( -->
<!--   nldr_data = scurve_umap5) -->
<!-- umap_scaled5 <- nldr_scaled_obj5$scaled_nldr -->

<!-- scurve_nldr5 <- umap_scaled5 |> -->
<!--   ggplot(aes(x = emb1, -->
<!--              y = emb2))+ -->
<!--   geom_point(alpha=0.1, size=1, colour='#636363') + -->
<!--   interior_annotation("e") -->

<!-- nldr_scaled_obj6 <- gen_scaled_data( -->
<!--   nldr_data = scurve_umap6) -->
<!-- umap_scaled6 <- nldr_scaled_obj6$scaled_nldr -->

<!-- scurve_nldr6 <- umap_scaled6 |> -->
<!--   ggplot(aes(x = emb1, -->
<!--              y = emb2))+ -->
<!--   geom_point(alpha=0.1, size=1, colour='#984ea3') + -->
<!--   interior_annotation("f") -->
<!-- ``` -->

<!-- ```{r} -->
<!-- scurve_error <- dplyr::bind_rows(scurve_umap_mse, -->
<!--                                  scurve_umap_mse2, -->
<!--                                  scurve_umap_mse3, -->
<!--                                  scurve_umap_mse4, -->
<!--                                  scurve_umap_mse5, -->
<!--                                  scurve_umap_mse6) -->

<!-- scurve_error <- scurve_error |> -->
<!--   mutate(a1 = round(a1, 2)) |> -->
<!--   filter(b1 >= 5) |> -->
<!--   group_by(method, a1) |> -->
<!--   filter(MSE == min(MSE)) |> -->
<!--   ungroup() -->

<!-- error_plot <- ggplot(scurve_error, -->
<!--          aes(x = a1, -->
<!--              y = sqrt(MSE), -->
<!--              color = method)) + -->
<!--     geom_point(size = 0.8) + -->
<!--     geom_line(linewidth = 0.3) + -->
<!--   scale_x_continuous(breaks = -->
<!--     sort(unique(scurve_error$a1))[ -->
<!--       seq(1, length( -->
<!--         unique(scurve_error$a1)),  -->
<!--         by = 5)]) + -->
<!--   scale_color_manual( -->
<!--     values=c('#e41a1c','#ff7f00','#4daf4a',  -->
<!--              "#a65628",'#636363', '#984ea3'))+ -->
<!--     ylab("RMSE") + -->
<!--     xlab(expression(paste("binwidth (", a[1], ")"))) + -->
<!--     theme_minimal() + -->
<!--     theme(panel.border = element_rect(fill = 'transparent'), -->
<!--           plot.title = element_text(size = 12, hjust = 0.5, vjust = -0.5), -->
<!--           axis.ticks.x = element_line(), -->
<!--           axis.ticks.y = element_line(), -->
<!--           legend.position = "none", -->
<!--           axis.text.x = element_text(size = 7), -->
<!--           axis.text.y = element_text(size = 7), -->
<!--           axis.title.x = element_text(size = 7), -->
<!--           axis.title.y = element_text(size = 7), -->
<!--           aspect.ratio = 1.5) -->
<!-- ``` -->

<!-- ```{r} -->
<!-- free(error_plot) + wrap_plots( -->
<!--   scurve_nldr1, scurve_nldr2,  -->
<!--   scurve_nldr3, scurve_nldr4, -->
<!--   scurve_nldr5, scurve_nldr6,  -->
<!--   ncol = 2) -->
<!-- ``` -->

# Computational efficiency and optimization

Several core computations within `quollr` are optimized using compiled C++ code via the `Rcpp` and `RcppArmadillo` packages. While the user interacts with high-level R functions, performance-critical steps such as nearest-neighbor searches (`compute_highd_dist()`), error metrics (`compute_errors()`), $2\text{-}D$ distance calculations (`calc_2d_dist_cpp()`), and generation of hexagon coordinates (`gen_hex_coord_cpp()`) are handled internally in C++. This design provides significant speedups when analyzing large datasets while maintaining a user-friendly R interface. These C++ functions are not exported but are bundled within the package and fully accessible for inspection in the source code.

# Application

Single-cell RNA sequencing (scRNA-seq) is a popular and powerful technology that allows you to profile the whole transcriptome of a large number of individual cells [@andrews2021]. 

Clustering of single-cell data is used to identify groups of cells with similar expression profiles. NLDR often used to summarise the discovered clusters, and help to understand the results. The purpose of this example is to *illustrate how to use our method to help decide on an appropriate NLDR layout that accurately represents the data*.

Limb muscle cells of mice in @tabula2018 are examined. There are $1067$ single cells, with $14997$ gene expressions. Following their pre-processing, different NLDR methods were performed using ten principal components. Figure \@ref(fig:limb-rmse) (b) is the reproduction of the published plot. The question is whether this accurately represents the cluster structure in the data. Our method help to provide a better $2\text{-}D$ layout. 

<!-- add function to generate 2D trimesh and the projections (PDF) and langevitour (HTML)-->

<!-- https://www.nature.com/articles/s41586-018-0590-4#data-availability -->
<!-- https://figshare.com/articles/dataset/Robject_files_for_tissues_processed_by_Seurat/5821263/1 -->

```{r}
#| label: read-limb-nldr
# Read a variety of different NLDR representations of limb
# and plot them on same aspect ratio

umap_limb <- read_rds("data/limb_muscles/facs_limb_muscles_umap_n-neigbors_15_min-dist_0.1.rds")

nldr1 <- umap_limb |>
  ggplot(aes(x = emb1,
             y = emb2)) +
  geom_point(alpha=0.1, size=1, colour='#999999') +
  interior_annotation("a")

tsne_limb <- read_rds("data/limb_muscles/facs_limb_muscles_tsne_perplexity_30.rds")

nldr2 <- tsne_limb |>
  ggplot(aes(x = emb1,
             y = emb2)) +
  geom_point(alpha=0.1, size=1, colour='#a65628') +
  interior_annotation("b")

phate_limb <- read_rds("data/limb_muscles/facs_limb_muscles_phate_knn_5.rds")

nldr3 <- phate_limb |>
  ggplot(aes(x = emb1,
             y = emb2)) +
  geom_point(alpha=0.1, size=1, colour='#e41a1c') +
  interior_annotation("c")

trimap_limb <- read_rds("data/limb_muscles/facs_limb_muscles_trimap_n-inliers_12_n-outliers_4_n-random_3.rds")

nldr4 <- trimap_limb |>
  ggplot(aes(x = emb1,
             y = emb2)) +
  geom_point(alpha=0.1, size=1, colour='#984ea3') +
  interior_annotation("d")

pacmap_limb <- read_rds("data/limb_muscles/facs_limb_muscles_pacmap_n-neighbors_10_init_random_MN-ratio_0.5_FP-ratio_2.rds")

nldr5 <- pacmap_limb |>
  ggplot(aes(x = emb1,
             y = emb2)) +
  geom_point(alpha=0.1, size=1, colour='#4daf4a') +
  interior_annotation("e")

tsne_limb2 <- read_rds("data/limb_muscles/facs_limb_muscles_tsne_perplexity_15.rds")

nldr6 <- tsne_limb2 |>
  ggplot(aes(x = emb1,
             y = emb2)) +
  geom_point(alpha=0.1, size=1, colour='#ff7f00') +
  interior_annotation("f")
```

```{r}
#| label: combine-error-data-muscles

error_limb_umap <- read_rds("data/limb_muscles/error_limb_muscles_umap_n-neigbors_15_min-dist_0.1.rds")
error_limb_tsne <- read_rds("data/limb_muscles/error_limb_muscles_tsne_perplexity_30.rds")
error_limb_phate <- read_rds("data/limb_muscles/error_limb_muscles_phate_knn_5.rds")
error_limb_trimap <- read_rds("data/limb_muscles/error_limb_muscles_trimap_n-inliers_12_n-outliers_4_n-random_3.rds")
error_limb_pacmap <- read_rds("data/limb_muscles/error_limb_muscles_pacmap_n-neighbors_10_init_random_MN-ratio_0.5_FP-ratio_2.rds")

error_limb_tsne2 <- read_rds("data/limb_muscles/error_limb_muscles_tsne_perplexity_15.rds")

error_limb <- bind_rows(error_limb_umap, 
                        error_limb_tsne,
                        error_limb_phate,
                        error_limb_trimap,
                        error_limb_pacmap,
                        error_limb_tsne2)

error_limb <- error_limb |>
  mutate(a1 = round(a1, 2)) |>
  filter(b1 >= 5) |>
  filter(a1 >= 0.03) |>
  group_by(method, a1) |>
  filter(RMSE == min(RMSE)) |>
  ungroup()

error_limb <- error_limb |>
  mutate(method = factor(method,
                         levels = c("UMAP_15_min_dist_0.1", "tsne_30", "phate_5", "trimap_n-inliers_12_n-outliers_4_n-random_3", "pacmap_n-neighbors_10_init_random_MN-ratio_0.5_FP-ratio_2", "tsne_15")))
```

```{r}
#| label: error-comp-muscles

error_plot_limb <- plot_rmse(error_limb) +
  scale_x_continuous(breaks = sort(unique(error_limb$a1))[c(1, 5, 9, 13, 17, 21, 26)]) +
  scale_color_manual(values=c('#999999','#a65628','#e41a1c','#984ea3','#4daf4a','#ff7f00')) 

```

```{r limb-rmse, fig.cap="Assessing which of the 6 NLDR layouts on the limb muscle data is the better representation using RMSE for varying binwidth ($a_1$). Colour  used for the lines and points in the left plot and in the scatterplots represents NLDR layout (a-f). Layout d is perform well at large binwidth (where the binwidth is not enough to capture the data struture) and poorly as bin width decreases. Layout f is the best choice.\\label{fig:limb-rmse}", fig.pos='H', echo=TRUE}

design <- gen_design(n_right = 6, ncol_right = 2)

plot_rmse_layouts(plots = list(error_plot_limb, nldr1, 
                               nldr2, nldr3, nldr4, 
                               nldr5, nldr6), design = design)
```

```{r data-limb}
data_limb <- read_rds("data/limb_muscles/facs_limb_muscles_pcs_10.rds")

cluster_df <- read_rds("data/limb_muscles/facs_limb_muscles_cluster_df.rds")
```

```{r}
#| label: tsne-model-limb

tsne_limb_obj <- fit_highd_model(
  highd_data = data_limb, 
  nldr_data = tsne_limb, 
  b1 = 19, 
  q = 0.1, 
  benchmark_highdens = 0)

df_bin_centroids_limb <- tsne_limb_obj$model_2d
df_bin_limb <- tsne_limb_obj$model_highd
trimesh_data_limb <- tsne_limb_obj$trimesh_data
tsne_limb_scaled <- tsne_limb_obj$nldr_obj$scaled_nldr

tsne_limb_scaled_with_cluster <- inner_join(tsne_limb_scaled, cluster_df, by = "ID") |>
  mutate(cluster = as.character(cluster.ids))

trimesh_limb <- ggplot() + 
  geom_point(
    data = tsne_limb_scaled_with_cluster,
    aes(
      x = emb1,
      y = emb2,
      color = cluster
    ),
    alpha = 0.3
  ) +
  geom_segment(data = trimesh_data_limb, 
               aes(
                 x = x_from, 
                 y = y_from, 
                 xend = x_to, 
                 yend = y_to),
               colour = "#000000",
               linewidth = 1) +
  scale_color_manual(values = c('#66c2a5','#fc8d62','#8da0cb','#e78ac3','#a6d854','#ffd92f','#e5c494')) +
  interior_annotation("a1", cex = 2) +
  theme(
    aspect.ratio = 1
  )

trimesh_limb_int <- ggplotly(trimesh_limb, 
                                width = "350", 
                                height = "350", 
                                tooltip = "none") |>
  config(
    staticPlot = TRUE,        # Disables all interactivity (no hover, zoom, pan)
    displayModeBar = FALSE,   # Hides the plotly toolbar
    editable = FALSE,         # Disables annotations and editing
    showTips = FALSE,         # Removes tooltip on hover
    displaylogo = FALSE,      # Hides plotly logo
    responsive = FALSE        # Disables responsive resizing
  )

# hex_grid <- tsne_limb_obj$hb_obj$hex_poly
# counts_df <- tsne_limb_obj$hb_obj$std_cts
# 
# hex_grid_with_counts <- left_join(hex_grid, counts_df, by = c("h" = "h"))
# 
# ggplot(data = hex_grid_with_counts, aes(x = x, y = y)) +
#   geom_polygon(color = "black", aes(group = hex_poly_id, fill = n_h)) +
#   #geom_text(data = all_centroids_df, aes(x = c_x, y = c_y, label = h)) +
#   scale_fill_viridis_c(direction = -1, na.value = "#ffffff") +
#   coord_fixed() +
#   theme_minimal()
```

```{r}
#| label: prep-limb-tsne-author-model-proj

data_limb_n <- data_limb |> 
  select(-ID) |>
  mutate(type = "data")

df_b_limb <- df_bin_limb |>
  dplyr::filter(h %in% df_bin_centroids_limb$h) |>
  dplyr::mutate(type = "model") ## Data with summarized mean

## Reorder the rows of df_b according to the h order in df_b_with_center_data
df_b_limb <- df_b_limb[match(df_bin_centroids_limb$h, df_b_limb$h),] |>
  dplyr::select(-h) 

# Apply the scaling
df_model_data_limb <- bind_rows(data_limb_n, df_b_limb)
scaled_limb <- scale_data_manual(df_model_data_limb, "type") |>
  as_tibble()

scaled_limb_data <- scaled_limb |>
  filter(type == "data") |>
  select(-type)

scaled_limb_data_model <- scaled_limb |>
  filter(type == "model") |>
  select(-type)
```

```{r langevitour-limb-tsne-author-proj}

data_limb_n <- data_limb_n |>
  select(-type) |>
  mutate(type = as.character(tsne_limb_scaled_with_cluster$cluster.ids))

df_model_data_limb_n <- bind_rows(df_b_limb, data_limb_n)

limb_highd_vis <- langevitour::langevitour(df_model_data_limb_n[1:(length(df_model_data_limb_n)-1)],
                         lineFrom = trimesh_data_limb$from,
                         lineTo = trimesh_data_limb$to,
                         group = factor(df_model_data_limb_n$type,
                                        c("0", "1", "2", "3", "4", "5", "6", "model")),
                         levelColors = c('#66c2a5','#fc8d62','#8da0cb','#e78ac3','#a6d854','#ffd92f','#e5c494', "#000000"),
                         enableControls = FALSE,
                         width = "421px", height = "421px")
```

```{r plot-proj}

## First projection
projection <- cbind(
  c(-0.021068,0.007018,0.008770,0.016884,-0.008135,0.011458,-0.022323,0.007231,0.004976,-0.019298),
  c(-0.017371,-0.008514,0.003231,-0.022945,-0.026264,-0.001571,0.008007,-0.001268,-0.016923,-0.006700))

proj_obj1 <- get_projection(projection = projection, 
                            proj_scale = 1.23, 
                            highd_data = scaled_limb_data, 
                            model_highd = scaled_limb_data_model, 
                            trimesh_data = trimesh_data_limb, 
                            axis_param = list(limits = 0.05,
                                              axis_scaled = 20, 
                                              axis_pos_x = -0.04, 
                                              axis_pos_y = -0.04, 
                                              threshold = 0.004))

proj_obj1[["cluster"]] <- as.character(tsne_limb_scaled_with_cluster$cluster)

limb_proj_tsne_model1 <- plot_proj(
  proj_obj = proj_obj1, 
  point_param = c(1.5, 0.2), # size, alpha, color
  plot_limits = c(-0.05, 0.03), 
  axis_text_size = 4,
  is_category = TRUE) +
  interior_annotation(label = "a2", cex = 2) + 
  scale_color_manual(values = c('#66c2a5','#fc8d62','#8da0cb','#e78ac3','#a6d854','#ffd92f','#e5c494'))

## Second projection
projection <- cbind(
  c(-0.025678,-0.017472,0.015634,-0.014868,-0.000752,0.001050,-0.019524,-0.008076,-0.010808,-0.002319),
  c(0.014526,-0.013526,-0.005147,-0.027612,-0.016919,0.005198,0.010710,0.004623,-0.007055,0.017842))

proj_obj2 <- get_projection(projection = projection, 
                            proj_scale = 1.23, 
                            highd_data = scaled_limb_data, 
                            model_highd = scaled_limb_data_model, 
                            trimesh_data = trimesh_data_limb, 
                            axis_param = list(limits = 0.05,
                                              axis_scaled = 20, 
                                              axis_pos_x = -0.03, 
                                              axis_pos_y = -0.03, 
                                              threshold = 0.004))

proj_obj2[["cluster"]] <- as.character(tsne_limb_scaled_with_cluster$cluster)

limb_proj_tsne_model2 <- plot_proj(
  proj_obj = proj_obj2, 
  point_param = c(1.5, 0.2), # size, alpha, color
  plot_limits = c(-0.04, 0.04), 
  axis_text_size = 4,
  is_category = TRUE) +
  interior_annotation(label = "a3", cex = 2) + 
  scale_color_manual(values = c('#66c2a5','#fc8d62','#8da0cb','#e78ac3','#a6d854','#ffd92f','#e5c494'))


```

```{r}
#| label: tsne-best-model-limb

tsne_best_limb_obj <- fit_highd_model(
  highd_data = data_limb, 
  nldr_data = tsne_limb2, 
  b1 = 19, 
  q = 0.1, 
  benchmark_highdens = 0)

df_bin_centroids_limb <- tsne_best_limb_obj$model_2d
df_bin_limb <- tsne_best_limb_obj$model_highd
trimesh_data_limb <- tsne_best_limb_obj$trimesh_data
tsne_limb_scaled <- tsne_best_limb_obj$nldr_obj$scaled_nldr

tsne_limb_scaled_with_cluster <- inner_join(tsne_limb_scaled, cluster_df, by = "ID") |>
  mutate(cluster = as.character(cluster.ids))

trimesh_limb_best <- ggplot() + 
  geom_point(
    data = tsne_limb_scaled_with_cluster,
    aes(
      x = emb1,
      y = emb2,
      color = cluster
    ),
    alpha = 0.3
  ) +
  geom_segment(data = trimesh_data_limb, 
               aes(
                 x = x_from, 
                 y = y_from, 
                 xend = x_to, 
                 yend = y_to),
               colour = "#000000",
               linewidth = 1) +
  scale_color_manual(values = c('#66c2a5','#fc8d62','#8da0cb','#e78ac3','#a6d854','#ffd92f','#e5c494')) +
  interior_annotation("b1", cex = 2) +
  theme(
    aspect.ratio = 1
  )

trimesh_limb_best_int <- ggplotly(trimesh_limb_best, 
                                width = "350", 
                                height = "350", 
                                tooltip = "none") |>
  config(
    staticPlot = TRUE,        # Disables all interactivity (no hover, zoom, pan)
    displayModeBar = FALSE,   # Hides the plotly toolbar
    editable = FALSE,         # Disables annotations and editing
    showTips = FALSE,         # Removes tooltip on hover
    displaylogo = FALSE,      # Hides plotly logo
    responsive = FALSE        # Disables responsive resizing
  )

# hex_grid <- tsne_best_limb_obj$hb_obj$hex_poly
# counts_df <- tsne_best_limb_obj$hb_obj$std_cts
# 
# hex_grid_with_counts <- left_join(hex_grid, counts_df, by = c("hex_poly_id" = "h"))
# 
# ggplot(data = hex_grid_with_counts, aes(x = x, y = y)) +
#   geom_polygon(color = "black", aes(group = hex_poly_id, fill = n_h)) +
#   #geom_text(data = all_centroids_df, aes(x = c_x, y = c_y, label = h)) +
#   scale_fill_viridis_c(direction = -1, na.value = "#ffffff") +
#   coord_fixed() +
#   theme_minimal()
```

```{r}
#| label: prep-limb-tsne-best-model-proj

data_limb_n <- data_limb |> 
  select(-ID) |>
  mutate(type = "data")

df_b_limb <- df_bin_limb |>
  dplyr::filter(h %in% df_bin_centroids_limb$h) |>
  dplyr::mutate(type = "model") ## Data with summarized mean

## Reorder the rows of df_b according to the h order in df_b_with_center_data
df_b_limb <- df_b_limb[match(df_bin_centroids_limb$h, df_b_limb$h),] |>
  dplyr::select(-h) 

# Apply the scaling
df_model_data_limb <- bind_rows(data_limb_n, df_b_limb)
scaled_limb <- scale_data_manual(df_model_data_limb, "type") |>
  as_tibble()

scaled_limb_data <- scaled_limb |>
  filter(type == "data") |>
  select(-type)

scaled_limb_data_model <- scaled_limb |>
  filter(type == "model") |>
  select(-type)
```

```{r langevitour-limb-tsne-best-proj}

data_limb_n <- data_limb_n |>
  select(-type) |>
  mutate(type = as.character(tsne_limb_scaled_with_cluster$cluster.ids))

df_model_data_limb_n <- bind_rows(df_b_limb, data_limb_n)

limb_highd_vis_best <- langevitour::langevitour(df_model_data_limb_n[1:(length(df_model_data_limb_n)-1)],
                         lineFrom = trimesh_data_limb$from,
                         lineTo = trimesh_data_limb$to,
                         group = factor(df_model_data_limb_n$type,
                                        c("0", "1", "2", "3", "4", "5", "6", "model")),
                         levelColors = c('#66c2a5','#fc8d62','#8da0cb','#e78ac3','#a6d854','#ffd92f','#e5c494', "#000000"),
                         enableControls = FALSE,
                         width = "421px", height = "421px")
```

```{r plot-proj-best}

## First projection
projection <- cbind(
  c(-0.021068,0.007018,0.008770,0.016884,-0.008135,0.011458,-0.022323,0.007231,0.004976,-0.019298),
  c(-0.017371,-0.008514,0.003231,-0.022945,-0.026264,-0.001571,0.008007,-0.001268,-0.016923,-0.006700))

proj_obj1 <- get_projection(projection = projection, 
                            proj_scale = 1.23, 
                            highd_data = scaled_limb_data, 
                            model_highd = scaled_limb_data_model, 
                            trimesh_data = trimesh_data_limb, 
                            axis_param = list(limits = 0.05,
                                              axis_scaled = 20, 
                                              axis_pos_x = -0.04, 
                                              axis_pos_y = -0.04, 
                                              threshold = 0.004))

proj_obj1[["cluster"]] <- as.character(tsne_limb_scaled_with_cluster$cluster)

limb_proj_tsne_best_model1 <- plot_proj(
  proj_obj = proj_obj1, 
  point_param = c(1.5, 0.2), # size, alpha, color
  plot_limits = c(-0.05, 0.03), 
  axis_text_size = 4,
  is_category = TRUE) +
  interior_annotation(label = "b2", cex = 2) + 
  scale_color_manual(values = c('#66c2a5','#fc8d62','#8da0cb','#e78ac3','#a6d854','#ffd92f','#e5c494'))

## Second projection
projection <- cbind(
  c(-0.025678,-0.017472,0.015634,-0.014868,-0.000752,0.001050,-0.019524,-0.008076,-0.010808,-0.002319),
  c(0.014526,-0.013526,-0.005147,-0.027612,-0.016919,0.005198,0.010710,0.004623,-0.007055,0.017842))

proj_obj2 <- get_projection(projection = projection, 
                            proj_scale = 1.23, 
                            highd_data = scaled_limb_data, 
                            model_highd = scaled_limb_data_model, 
                            trimesh_data = trimesh_data_limb, 
                            axis_param = list(limits = 0.05,
                                              axis_scaled = 20, 
                                              axis_pos_x = -0.03, 
                                              axis_pos_y = -0.03, 
                                              threshold = 0.004))

proj_obj2[["cluster"]] <- as.character(tsne_limb_scaled_with_cluster$cluster)

limb_proj_tsne_best_model2 <- plot_proj(
  proj_obj = proj_obj2, 
  point_param = c(1.5, 0.2), # size, alpha, color
  plot_limits = c(-0.04, 0.04), 
  axis_text_size = 4,
  is_category = TRUE) +
  interior_annotation(label = "b3", cex = 2) + 
  scale_color_manual(values = c('#66c2a5','#fc8d62','#8da0cb','#e78ac3','#a6d854','#ffd92f','#e5c494'))


```

```{r model-limb, fig.cap="Compare the published $2-\\text{D}$ layout (Figure \\ref{fig:limb-rmse}b) and the $2-\\text{D}$ layout selected (Figure \\ref{fig:limb-rmse}f) by RMSE plot (Figure \\ref{fig:limb-rmse}) from the tSNE, UMAP, PHATE, TriMAP, and PaCMAP with different hyper-parameters. The Limb muscle data ($n =  1067$) has seven close different shaped clusters in $10\\text{-}D$.", fig.pos='H', fig.width=15, fig.height=10, eval=knitr::is_latex_output()}

trimesh_limb + limb_proj_tsne_model1 +
  limb_proj_tsne_model2 + trimesh_limb_best +
  limb_proj_tsne_best_model1 + limb_proj_tsne_best_model2 +
  plot_layout(nrow = 2)
```

```{r model-limb-html, eval=knitr::is_html_output(), fig.cap="Compare the published $2-\\text{D}$ layout (Figure \\@ref(fig:limb-rmse) b) and the $2-\\text{D}$ layout selected (Figure \\@ref(fig:limb-rmse) f) by RMSE plot (Figure \\@ref(fig:limb-rmse)) from the tSNE, UMAP, PHATE, TriMAP, and PaCMAP with different hyper-parameters. The Limb muscle data ($n =  1067$) has seven close different shaped clusters in $10\\text{-}D$."}


modellimbfig <- htmltools::div(
        style = "display: grid; grid-template-columns: 1fr 1fr; row-gap: 0px; justify-items: center;",
        trimesh_limb_int,
        htmltools::div(style = "margin-top: 13px;", limb_highd_vis),
        trimesh_limb_best_int,
        htmltools::div(style = "margin-top: 13px;", limb_highd_vis_best)
      )

class(modellimbfig) <- c(class(modellimbfig), "htmlwidget")

modellimbfig
```

# Discussion

The `quollr` package introduces a new framework for interpreting NLDR outputs by fitting a geometric wireframe model in $2\text{-}D$ and lifting it into high-dimensional space. This lifted model provides a direct way to assess how well a $2\text{-}D$ layout, produced by methods such as tSNE, UMAP, PHATE, TriMAP, or PaCMAP, preserves the structure of the original high-dimensional data. The approach offers both numerical and visual diagnostics to support the selection of NLDR methods and tuning hyper-parameters that produce the most accurate $2\text{-}D$ representations.

In contrast to the common practice of visually inspecting scatterplots for clusters or patterns, `quollr` provides a quantitative route for evaluation. It enables the computation of RMSE and residuals between the original high-dimensional data and the lifted model, offering interpretable diagnostics. These diagnostics are complemented by interactive linked plots and high-dimensional dynamic visualizations using the `langevitour` package, allowing users to inspect where the model fits well and where it does not.

To support efficient computation, particularly for large-scale datasets, several core functions in `quollr` are implemented in C++ using `Rcpp` and `RcppArmadillo`. These include functions for computing Euclidean distances in high-dimensional and $2\text{-}D$ space, identifying nearest centroids, calculating residual errors, and generating polygonal coordinates of hexagons. For instance, `compute_highd_dist()` accelerates nearest neighbor lookup in high-dimensional space, `compute_errors()` calculates RMSE and total absolute error efficiently, and `calc_2d_dist_cpp()` speeds up distance calculations in $2\text{-}D$. Additionally, `gen_hex_coord_cpp()` constructs the coordinates for hexagonal bins based on their centroids with minimal overhead. These optimizations result in substantial performance gains compared to native R implementations, making the package responsive even when used in interactive contexts or on large datasets such as single-cell transcriptomic profiles.

The modular structure of the package is designed to support both flexibility and reproducibility. Users can access individual functions to control each step of the pipeline such as scaling, binning, and triangulation or use the main function `fit_highd_model()` for end-to-end model construction. The diagnostics can be used not only to compare NLDR methods but also to tune binning parameters, assess layout stability, and detect local distortions in the embedding.

There are several avenues for future development. While hexagonal binning provides a regular structure conducive to modeling, alternative spatial discretizations (e.g., adaptive binning or density-aware tessellations) could be explored to better capture varying data densities. Expanding support for additional distance metrics in the lifting and prediction steps may improve performance across different domains. Additionally, statistical inference tools could be introduced to assess the stability and robustness of the fitted model, which would enhance interpretability and confidence in the outcomes. 

# Acknowledgements

The source code for reproducing this paper can be found at: [https://github.com/JayaniLakshika/paper-quollr](https://github.com/JayaniLakshika/paper-quollr).

This article is created using \CRANpkg{knitr} [@knitr] and \CRANpkg{rmarkdown} [@rmarkdown] in R with the `rjtools::rjournal_article` template. These `R` packages were used for this work: `cli` [@gabor2025], `dplyr` [@hadley2023], `ggplot2` [@hadley2016], `interp` (>= 1.1-6) [@albrecht2024], `langevitour` [@paul2023], `proxy`[@david2022], `stats` [@core2025], `tibble` [@kirill2023], `tidyselect` [@lionel2024], `crosstalk` [@joe2023], `plotly` [@chapman2020], `kableExtra` [@hao2024], `patchwork` [@thomas2024], and `readr` [@hadley2024].
