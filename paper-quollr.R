# Generated by `rjournal_pdf_article()` using `knitr::purl()`: do not edit by hand
# Please edit paper-quollr.Rmd to modify this file

## ----setup, include=FALSE-----------------------------------------------------
options(repos = "https://cloud.r-project.org") ## set up CRAN mirror
knitr::opts_chunk$set(
  echo = FALSE, 
  cache=FALSE, 
  message=FALSE, 
  warning=FALSE,
  comment = ">",
  out.width = "100%",
  htmlwidgets.sizing = TRUE)



## ----install-libraries, include=FALSE, warning=FALSE, echo=FALSE, eval=FALSE----
# 
# # Ensure remotes is available
# if (!requireNamespace("remotes", quietly = TRUE)) {
#   install.packages("remotes")
# }
# 
# # Read the package list
# pkgs_raw <- readLines("_Rpackages.txt")
# pkgs_raw <- pkgs_raw[nzchar(pkgs_raw)]  # remove empty lines
# 
# # Split into package and version
# parts <- strsplit(pkgs_raw, "==")
# pkgs <- vapply(parts, `[[`, "", 1)
# versions <- vapply(parts, `[[`, "", 2)
# 
# # Install packages with exact versions
# for (i in seq_along(pkgs)) {
#   pkg <- pkgs[i]
#   ver <- versions[i]
# 
#   if (!requireNamespace(pkg, quietly = TRUE) ||
#       as.character(packageVersion(pkg)) != ver) {
# 
#     message(sprintf("Installing %s (%s)", pkg, ver))
#     remotes::install_version(pkg, version = ver, upgrade = "never")
#   }
# }
# 


## ----load-libraries-----------------------------------------------------------
library(quollr)
library(tibble)
library(knitr)
library(kableExtra)
library(ggplot2)
library(dplyr)
library(patchwork)
library(readr)
library(plotly)
library(crosstalk)
library(htmltools)
library(detourr)

set.seed(20240110)


## ----plot-theme---------------------------------------------------------------
theme_set(theme_linedraw() +
   theme(
     aspect.ratio = 1,
     plot.background = element_rect(fill = 'transparent', colour = NA),
     plot.title = element_text(size = 7, hjust = 0.5, vjust = -0.5),
     panel.background = element_rect(fill = 'transparent', 
                                     colour = NA),
     panel.grid.major = element_blank(), 
     panel.grid.minor = element_blank(), 
     axis.title.x = element_blank(), axis.title.y = element_blank(),
     axis.text.x = element_blank(), axis.ticks.x = element_blank(),
     axis.text.y = element_blank(), axis.ticks.y = element_blank(),
     legend.background = element_rect(fill = 'transparent', 
                                      colour = NA),
     legend.key = element_rect(fill = 'transparent', 
                               colour = NA),
     legend.position = "none", 
     legend.title = element_text(size=5), 
     legend.text = element_text(size=4),
     legend.key.height = unit(0.25, 'cm'),
     legend.key.width = unit(0.25, 'cm'),
     plot.margin = margin(0, 0, 0, 0)
   )

)


## -----------------------------------------------------------------------------
#| label: import-scripts
source("scripts/additional_functions.R")


## -----------------------------------------------------------------------------
clr_choice <- "#66B2CC"

scurve_model_obj <- fit_highd_model(
  highd_data = scurve, 
  nldr_data = scurve_umap, 
  b1 = 21, 
  q = 0.1, 
  hd_thresh = 0)

scurve_umap_scaled <- scurve_model_obj$nldr_scaled_obj$scaled_nldr
tr_from_to_df_scurve <- scurve_model_obj$trimesh_data
df_bin_centroids_scurve <- scurve_model_obj$model_2d
df_bin_scurve <- scurve_model_obj$model_highd
hex_grid_scurve <- scurve_model_obj$hb_obj$hex_poly
counts_df_scurve <- scurve_model_obj$hb_obj$std_cts

hex_grid_with_counts_scurve <- left_join(
  hex_grid_scurve, counts_df_scurve, 
  by = c("h" = "h"))

hex_grid_nonempty_scurve <- hex_grid_scurve |>
  filter(h %in% df_bin_centroids_scurve$h)

sc_xlims <- c(-0.25, 1.35)
sc_ylims <- c(-0.25, 1.35)

scurve_umap_plt <- ggplot(
  scurve_umap_scaled, 
  aes(x = emb1, y = emb2)) +
  geom_point(alpha = 0.5, color = clr_choice, size = 0.5) +
  interior_annotation("a", cex = 1) +
  xlim(sc_xlims) +
  ylim(sc_ylims)

scurve_umap_plt_int <- ggplotly(scurve_umap_plt, 
                                width = "350", 
                                height = "350", 
                                tooltip = "none") |>
  config(
    staticPlot = TRUE,        # Disables all interactivity (no hover, zoom, pan)
    displayModeBar = FALSE,   # Hides the plotly toolbar
    editable = FALSE,         # Disables annotations and editing
    showTips = FALSE,         # Removes tooltip on hover
    displaylogo = FALSE,      # Hides plotly logo
    responsive = FALSE        # Disables responsive resizing
  )

hex_grid_poly_scurve <- ggplot(
  data = hex_grid_with_counts_scurve, 
  aes(x = x, y = y)) +
  geom_polygon(color = "grey70", 
               aes(group = h), 
               fill = "#ffffff") +
  geom_point(data = scurve_umap_scaled, 
             aes(x = emb1, y = emb2), 
             alpha = 0.8, size = 0.5, color = clr_choice) + 
  interior_annotation("a", cex = 1) +
  xlim(sc_xlims) +
  ylim(sc_ylims)

hex_grid_poly_scurve_int <- ggplotly(hex_grid_poly_scurve, 
                                width = "400", 
                                height = "380", 
                                tooltip = "none") |>
  config(
    staticPlot = TRUE,        # Disables all interactivity (no hover, zoom, pan)
    displayModeBar = FALSE,   # Hides the plotly toolbar
    editable = FALSE,         # Disables annotations and editing
    showTips = FALSE,         # Removes tooltip on hover
    displaylogo = FALSE,      # Hides plotly logo
    responsive = FALSE        # Disables responsive resizing
  )

hex_centroids_scurve <- ggplot(
  data = hex_grid_with_counts_scurve, 
  aes(x = x, y = y)) +
  geom_polygon(color = "grey70", 
               aes(group = h), 
               fill = "#ffffff")  +
  geom_point(data = df_bin_centroids_scurve, 
             aes(x = c_x, y = c_y), 
             size = 1, color = "#FF7755") +
  interior_annotation("b", cex = 1) +
  xlim(sc_xlims) +
  ylim(sc_ylims)

hex_centroids_scurve_int <- ggplotly(hex_centroids_scurve, 
                                width = "400", 
                                height = "380", 
                                tooltip = "none") |>
  config(
    staticPlot = TRUE,        # Disables all interactivity (no hover, zoom, pan)
    displayModeBar = FALSE,   # Hides the plotly toolbar
    editable = FALSE,         # Disables annotations and editing
    showTips = FALSE,         # Removes tooltip on hover
    displaylogo = FALSE,      # Hides plotly logo
    responsive = FALSE        # Disables responsive resizing
  )

wireframe_scurve <- ggplot() +
  geom_segment(data = tr_from_to_df_scurve,
               aes(
                 x = x_from,
                 y = y_from,
                 xend = x_to,
                 yend = y_to),
               colour = "#000000") +
  geom_point(data = df_bin_centroids_scurve, 
             aes(x = c_x, y = c_y), 
             size = 1, color = "#FF7755") +
  interior_annotation("c", cex = 1) +
  xlim(sc_xlims) +
  ylim(sc_ylims)

wireframe_scurve_int <- plot_ly() |>
    # Wireframe segments
    add_segments(
        data = tr_from_to_df_scurve,
        x = ~x_from, y = ~y_from,
        xend = ~x_to, yend = ~y_to,
        line = list(color = "#000000", width = 0.5),
        hoverinfo = "none",
        showlegend = FALSE
    ) |>
    # Centroid points
    add_markers(
        data = df_bin_centroids_scurve,
        x = ~c_x, y = ~c_y,
        marker = list(size = 4, color = "#FF7755"),
        hoverinfo = "none",
        showlegend = FALSE
    ) |>
    # Layout with border
    layout(
        width = 350,
        height = 320,
        xaxis = list(
            range = sc_xlims,
            showgrid = FALSE,
            zeroline = FALSE,
            showticklabels = FALSE,
            ticks = "",
            title = ""
        ),
        yaxis = list(
            range = sc_ylims,
            showgrid = FALSE,
            zeroline = FALSE,
            showticklabels = FALSE,
            ticks = "",
            title = ""
        ),
        
        # ADD A BOX AROUND THE ENTIRE PLOT PANEL
        shapes = list(
            list(
                type = "rect",
                xref = "paper", yref = "paper",
                x0 = 0, y0 = 0,
                x1 = 1, y1 = 1,
                line = list(color = "black", width = 1)
            )
        )
    ) |>
    config(
        staticPlot = TRUE,
        displayModeBar = FALSE,
        editable = FALSE,
        showTips = FALSE,
        displaylogo = FALSE,
        responsive = FALSE
    )

## 2-d vis model
hex_grid_scurve <- ggplot(
  data = hex_grid_with_counts_scurve, 
  aes(x = x, y = y)) +
  geom_point(data = scurve_umap_scaled, 
             aes(x = emb1, y = emb2), 
             size = 0.5, color = clr_choice) +
  geom_segment(data = tr_from_to_df_scurve,
               aes(
                 x = x_from,
                 y = y_from,
                 xend = x_to,
                 yend = y_to),
               colour = "#000000") +
  geom_point(data = df_bin_centroids_scurve, 
             aes(x = c_x, y = c_y), 
             size = 1, color = "#FF7755")

hex_grid_scurve_int <- ggplotly(hex_grid_scurve, 
                                width = "350", 
                                height = "380", 
                                tooltip = "none") |>
  config(
    staticPlot = TRUE,        # Disables all interactivity (no hover, zoom, pan)
    displayModeBar = FALSE,   # Hides the plotly toolbar
    editable = FALSE,         # Disables annotations and editing
    showTips = FALSE,         # Removes tooltip on hover
    displaylogo = FALSE,      # Hides plotly logo
    responsive = FALSE        # Disables responsive resizing
  )


## High-d vis model
df_exe <- comb_data_model(
    highd_data = scurve, 
    model_highd = df_bin_scurve, 
    model_2d = df_bin_centroids_scurve
)

df <- df_exe |>
    dplyr::filter(type == "data") ## original dataset

df_b <- df_exe |>
  dplyr::filter(type == "model") ## High-d model

scurve_umap_model_vis <- langevitour::langevitour(df_exe[1:(length(df_exe)-1)],
                         lineFrom = tr_from_to_df_scurve$from_reindexed,
                         lineTo = tr_from_to_df_scurve$to_reindexed,
                         group = df_exe$type,
                         pointSize = append(rep(2, NROW(df_b)), rep(1, NROW(df))),
                         levelColors = c(clr_choice, "#FF7755"),
                         enableControls = FALSE,
                         width = "400px", height = "380px")

scurve_umap_model_vis_n <- langevitour::langevitour(df_exe[1:(length(df_exe)-1)],
                         lineFrom = tr_from_to_df_scurve$from_reindexed,
                         lineTo = tr_from_to_df_scurve$to_reindexed,
                         group = df_exe$type,
                         pointSize = append(rep(2, NROW(df_b)), rep(1, NROW(df))),
                         levelColors = c(clr_choice, "#FF7755"),
                         enableControls = FALSE,
                         width = "400px", height = "550px")



## ----overviewhtml, eval=knitr::is_html_output(), fig.cap="Wireframe model representation of the NLDR layout, lifted and displayed in high-dimensional space. The left panel shows the NLDR layout with a triangular mesh overlay, forming the wireframe structure. This mesh can be lifted into higher dimensions and projected to examine how the geometric structure of the data is preserved. Panels (a1–a4) display different $2\\text{-}D$ projections of the lifted wireframe, where the underlying curved sheet structure of the data is more clearly visible. The triangulated mesh highlights how local neighborhoods in the layout correspond to relationships in the high-dimensional space, enabling diagnostics of distortion and preservation across dimensions.", fig.pos="!ht", layout = "l-body", fig.alt="The UMAP layout with a triangular mesh on the left and 2-D projections of the lifted wireframe overlaying the data on the right. The mesh illustrates how local neighborhoods in the 2-D embedding correspond to curved sheet structures in the original high-dimensional S-curve data."----
# 
# overviewfig <- bscols(
#   htmltools::div(
#     style = "
#       display: flex;
#       justify-content: center;  /* centers the whole grid */
#       margin: 0 auto;
#       padding: 0;
#     ",
#     htmltools::div(
#       style = "
#         display: grid;
#         grid-template-columns: 1fr 1fr;
#         gap: 0px;
#         align-items: start;
#         justify-items: center;
#         margin: 0;
#         padding: 0;
#       ",
#       htmltools::div(style = "margin: 0; padding: 0;", hex_grid_scurve_int),
#       htmltools::div(style = "margin: 0; margin-top: 13px; padding: 0;", scurve_umap_model_vis)
#     )
#   ),
#   device = "xs"
# )
# 
# # Ensure it's treated as a widget
# class(overviewfig) <- c(class(overviewfig), "htmlwidget")
# 
# overviewfig


## ----scurve-projections-------------------------------------------------------

df_b_scurve <- df_bin_scurve |>
  dplyr::filter(h %in% df_bin_centroids_scurve$h) |>
  dplyr::mutate(type = "model") ## Data with summarized mean

## Reorder the rows of df_b according to the h order in df_b_with_center_data
df_b_scurve <- df_b_scurve[match(df_bin_centroids_scurve$h, df_b_scurve$h),] |>
  dplyr::select(-h) 

scurve_labeled <- scurve |>
  select(-ID) |>
  mutate(type = "data")

# Apply the scaling
df_model_data_scurve <- bind_rows(scurve_labeled, df_b_scurve)
scaled_scurve <- center_data(df_model_data_scurve[,-8]) |>
  as_tibble() |>
  mutate(type = df_model_data_scurve$type)

scaled_scurve_data <- scaled_scurve |>
  filter(type == "data") |>
  select(-type)

scaled_scurve_data_model <- scaled_scurve |>
  filter(type == "model") |>
  select(-type)


## First projection
projection <- cbind(
  c(0.10479,0.06673,0.19430,-0.14763,0.02861,-0.04302,0.06601),
  c(0.11421,0.18556,-0.16860,-0.05033,-0.00219,0.04159,0.04285))

proj_obj1 <- get_projection(projection = projection, 
                            highd_data = scaled_scurve_data, 
                            model_highd = scaled_scurve_data_model, 
                            trimesh_data = tr_from_to_df_scurve, 
                            axis_param = list(limits = 0.8, 
                                              axis_scaled = 3,
                                              axis_pos_x = -0.35, 
                                              axis_pos_y = -0.35, 
                                              threshold = 0.0623))

scurve_proj_umap_model1 <- plot_proj(
  proj_obj = proj_obj1,
  point_param = c(0.5, 0.2, clr_choice), # size, alpha, color
  line_param = c(0.5, 0.3, "#000000"),
  plot_limits = c(-0.5, 0.55), 
  axis_text_size = 2,
  is_category = FALSE) +
  interior_annotation(label = "a1", cex = 1)

scurve_proj_umap_model1_dp <- plot_proj(
  proj_obj = proj_obj1,
  point_param = c(0.2, 0, clr_choice), # size, alpha, color
  line_param = c(0.5, 0.3, "#000000"),
  plot_limits = c(-0.5, 0.55), 
  axis_text_size = 3,
  is_category = FALSE) +
  interior_annotation(label = "d", cex = 1)

## Second projection

projection <- cbind(
  c(0.01588,-0.13640,-0.17180,-0.15486,-0.09726,0.00858,0.01090),
  c(0.21443,-0.00390,0.08182,-0.11746,0.06820,-0.05458,-0.08885))

proj_obj2 <- get_projection(projection = projection, 
                            highd_data = scaled_scurve_data, 
                            model_highd = scaled_scurve_data_model, 
                            trimesh_data = tr_from_to_df_scurve, 
                            axis_param = list(limits = 0.6, 
                                              axis_scaled = 3,
                                              axis_pos_x = -0.35, 
                                              axis_pos_y = -0.35, 
                                              threshold = 0.05))

proj_obj2_cp <- get_projection(projection = projection, 
                            highd_data = scaled_scurve_data, 
                            model_highd = scaled_scurve_data_model, 
                            trimesh_data = tr_from_to_df_scurve, 
                            axis_param = list(limits = 0.6, 
                                              axis_scaled = 3,
                                              axis_pos_x = -0.4, 
                                              axis_pos_y = -0.4, 
                                              threshold = 0.05))

scurve_proj_umap_model2 <- plot_proj(
  proj_obj = proj_obj2,
  point_param = c(0.5, 0.2, clr_choice), # size, alpha, color
  line_param = c(0.5, 0.3, "#000000"),
  plot_limits = c(-0.45, 0.4), 
  axis_text_size = 2,
  is_category = FALSE) +
  interior_annotation(label = "a2", cex = 1) 

## Third projection

projection <- cbind(
  c(0.02727,0.09154,-0.16383,-0.04931,-0.17013,0.11965,-0.01884),
  c(-0.10510,-0.10971,-0.09084,0.19642,-0.07163,-0.02486,0.07965))

proj_obj3 <- get_projection(projection = projection, 
                            highd_data = scaled_scurve_data, 
                            model_highd = scaled_scurve_data_model, 
                            trimesh_data = tr_from_to_df_scurve, 
                            axis_param = list(limits = 0.5, 
                                              axis_scaled = 3,
                                              axis_pos_x = -0.34, 
                                              axis_pos_y = -0.34, 
                                              threshold = 0.0462))

scurve_proj_umap_model3 <- plot_proj(
  proj_obj = proj_obj3,
  point_param = c(0.5, 0.2, clr_choice), # size, alpha, color
  line_param = c(0.5, 0.3, "#000000"),
  plot_limits = c(-0.43, 0.35), 
  axis_text_size = 2,
  is_category = FALSE) +
  interior_annotation(label = "a3", cex = 1) 

## Fourth projection

projection <- cbind(
  c(0.17174,0.14255,0.11950,0.10344,-0.07148,-0.01656,0.04275),
  c(0.09270,0.04486,-0.14397,0.08305,0.11783,0.16187,-0.06077))

proj_obj4 <- get_projection(projection = projection, 
                            highd_data = scaled_scurve_data, 
                            model_highd = scaled_scurve_data_model, 
                            trimesh_data = tr_from_to_df_scurve, 
                            axis_param = list(limits = 0.6, 
                                              axis_scaled = 3,
                                              axis_pos_x = -0.35, 
                                              axis_pos_y = -0.35, 
                                              threshold = 0.048))

scurve_proj_umap_model4 <- plot_proj(
  proj_obj = proj_obj4,
  point_param = c(0.5, 0.2, clr_choice), # size, alpha, color
  line_param = c(0.5, 0.3, "#000000"),
  plot_limits = c(-0.45, 0.46), 
  axis_text_size = 2,
  is_category = FALSE) +
  interior_annotation(label = "a4", cex = 1) 


## ----overview, eval=knitr::is_latex_output(), fig.cap="Wireframe model representation of the NLDR layout, lifted and displayed in high-dimensional space. The left panel shows the NLDR layout with a triangular mesh overlay, forming the wireframe structure. This mesh can be lifted into higher dimensions and projected to examine how the geometric structure of the data is preserved. Panels (a1–a4) display different $2\\text{-}D$ projections of the lifted wireframe, where the underlying curved sheet structure of the data is more clearly visible. The triangulated mesh highlights how local neighborhoods in the layout correspond to relationships in the high-dimensional space, enabling diagnostics of distortion and preservation across dimensions.", fig.pos="!ht", fig.alt="The UMAP layout with a triangular mesh on the left and the tour view of the lifted wireframe overlaying the data on the right. The mesh illustrates how local neighborhoods in the 2-D embedding correspond to curved sheet structures in the original high-dimensional S-curve data."----

hex_grid_scurve + wrap_plots(
  scurve_proj_umap_model1, scurve_proj_umap_model2,
  scurve_proj_umap_model3, scurve_proj_umap_model4, 
  ncol = 2)


## ----echo=TRUE, eval=TRUE-----------------------------------------------------
model_obj <- fit_highd_model(
  highd_data = scurve, 
  nldr_data = scurve_umap, 
  b1 = 21, 
  q = 0.1, 
  hd_thresh = 0)


## ----echo=TRUE, eval=TRUE-----------------------------------------------------
combined_data <- comb_data_model(
  highd_data = scurve,
  model_highd = model_obj$model_highd,
  model_2d = model_obj$model_2d
)

tour_view <- show_langevitour(
  point_data = combined_data,
  edge_data = model_obj$trimesh_data
)


## ----workflow, out.width = "100%", fig.pos="H", fig.cap="Overview of the `quollr` workflow and software architecture. The process begins with NLDR and $p\\text{-}D$ data inputs, followed by data preprocessing and hexagonal binning. Centroids are computed and triangulated to form the $2\\text{-}D$ mesh, which is then lifted into the $p\\text{-}D$ space. Predictions and error computations are performed on new data, while interactive functions enable dynamic linking between the $p\\text{-}D$ and $2\\text{-}D$ representations.", fig.alt = "The figure is a schematic diagram illustrating the quollr workflow and software architecture. Rectangular boxes represent processing steps and data objects, including NLDR and p-D data inputs, data preprocessing, hexagonal binning, centroid computation, triangulation, and construction of a 2-D mesh. Arrows indicate the flow of information between steps, from the input data through the 2-D mesh, and then from the mesh being lifted into the p-D space. Additional boxes show prediction and error computation for new data, as well as interactive components that link the p-D and 2-D representations. The diagram is laid out sequentially, showing how data move through the system from input to interactive output."----

knitr::include_graphics("figures/quollr_workflow.png")


## ----algo-step-html, eval=knitr::is_html_output(), fig.pos="!ht", fig.cap="Key steps for constructing the model on the UMAP layout: (a) hexagon bins, (b) bin centroids, (c) triangulated centroids, and (d) lifting the model into high dimensions. The `scurve` data is shown.", layout = "l-body", fig.alt = "The figure consists of four panels illustrating steps in constructing a model on a UMAP layout using the scurve data. Panel (a) is a static 2-D scatter plot of the UMAP embedding with points grouped into hexagonal bins. Panel (b) shows the same 2-D layout with a single centroid point displayed for each hexagonal bin. Panel (c) shows the centroids connected by straight line segments to form a triangulated mesh across the 2-D layout. Panel (d) is atour view in which the triangulated 2-D mesh is lifted into the original high-dimensional space and displayed as a continuously changing 2-D projection; the axes represent linear combinations of the original dimensions, and the mesh rotates and changes orientation as the view updates. The 2-D panels use bounded numeric axes with roughly square aspect ratios, while the tour view shows the lifted structure from multiple viewing angles."----
# 
# algofig <- bscols(
#   htmltools::div(
#     style = "
#       display: flex;
#       justify-content: center;     /* centers the grid horizontally */
#       align-items: center;          /* optional: centers vertically if space allows */
#       margin: 0 auto;
#       padding: 0;
#     ",
#     htmltools::div(
#       style = "
#         display: grid;
#         grid-template-columns: 1fr 1fr;
#         gap: 0px;
#         align-items: start;
#         justify-items: center;
#         margin: 0;
#         padding: 0;
#       ",
#       htmltools::div(style = 'margin: 0; padding: 0;  height: 450px; width: 200px; text-align: left;', htmltools::h5("a"), hex_grid_poly_scurve_int),
#       htmltools::div(style = 'margin: 0; padding: 0; height: 450px; width: 200px; text-align: left;', htmltools::h5("b"), hex_centroids_scurve_int),
#       htmltools::div(style = 'margin: 0; padding: 0; height: 400px; width: 200px;  text-align: left;', htmltools::h5("c"), wireframe_scurve_int),
#       htmltools::div(style = 'margin: 0; padding: 0; height: 400px; width: 485px; text-align: left;', htmltools::div(
#     style = "margin-left: 140px;",
#     htmltools::h5("d"),
#     htmltools::div(style = "margin-left: 30px; margin-top: 47px; height: 360px; width: 360px;", scurve_umap_model_vis_n)
#   ))
#     )
#   ),
#   device = "xs"
# )
# 
# # Treat as HTML widget
# class(algofig) <- c(class(algofig), "htmlwidget")
# 
# algofig


## ----algo-steps, eval=knitr::is_latex_output(), out.width="80%", fig.height=5, fig.width=25, fig.pos="!ht", fig.align='center', fig.cap="Key steps for constructing the model on the UMAP layout: (a) hexagon bins, (b) bin centroids, (c) triangulated centroids, and (d) lifting the model into high dimensions. The \\texttt{scurve} data is shown.", fig.alt = "The figure is a multi-panel diagram illustrating four steps in constructing a model on a UMAP layout using the scurve data. Panel (a) shows a 2-D UMAP scatter plot with points grouped into hexagonal bins covering the layout. Panel (b) shows the same layout with a centroid point displayed for each hexagon bin. Panel (c) shows the centroids connected by straight line segments to form a triangulated mesh across the 2-D layout. Panel (d) shows this 2-D triangulated mesh lifted into the original high-dimensional space, where the mesh appears as a curved surface. The horizontal and vertical axes in the 2-D panels represent the two UMAP coordinates with bounded numeric ranges, while the lifted view represents coordinates in the higher-dimensional space without explicit axis scales."----

hex_grid_poly_scurve +
  hex_centroids_scurve + wireframe_scurve + 
  scurve_proj_umap_model1_dp +
  plot_layout(ncol = 2)


## ----echo=TRUE----------------------------------------------------------------
scurve_umap_obj <- gen_scaled_data(nldr_data = scurve_umap)


## ----echo=TRUE----------------------------------------------------------------
bin_configs <- calc_bins_y(
  nldr_scaled_obj = scurve_umap_obj, 
  b1 = 21, 
  q = 0.1)

bin_configs


## ----echo=TRUE----------------------------------------------------------------
all_centroids_df <- gen_centroids(
  nldr_scaled_obj = scurve_umap_obj, 
  b1 = 21, 
  q = 0.1
)

head(all_centroids_df, 5)


## ----echo=TRUE----------------------------------------------------------------
all_hex_coord <- gen_hex_coord(
  centroids_data = all_centroids_df, 
  a1 = bin_configs$a1
)

head(all_hex_coord, 5)


## ----echo=TRUE----------------------------------------------------------------
umap_hex_id <- assign_data(
  nldr_scaled_obj = scurve_umap_obj, 
  centroids_data = all_centroids_df
)

head(umap_hex_id, 5)


## ----echo=TRUE----------------------------------------------------------------
pts_df <- group_hex_pts(
  scaled_nldr_hexid = umap_hex_id
)

head(pts_df, 5)


## ----echo=TRUE----------------------------------------------------------------
hb_obj <- hex_binning(
  nldr_scaled_obj = scurve_umap_obj, 
  b1 = 21, 
  q = 0.1)


## ----echo=TRUE----------------------------------------------------------------
std_df <- compute_std_counts(
  scaled_nldr_h = umap_hex_id
  )

head(std_df, 5)


## ----echo=TRUE----------------------------------------------------------------
df_bin_centroids <- merge_hexbin_centroids(
  centroids_data = all_centroids_df, 
  counts_data = hb_obj$std_cts
  )

head(df_bin_centroids, 5)


## ----echo=TRUE----------------------------------------------------------------
tr_object <- tri_bin_centroids(
  centroids_data = df_bin_centroids
  )


## ----echo=TRUE----------------------------------------------------------------
trimesh <- gen_edges(tri_object = tr_object, a1 = hb_obj$a1)

head(trimesh, 5)


## ----echo=TRUE----------------------------------------------------------------
trimesh <- update_trimesh_index(trimesh_data = trimesh)

head(trimesh, 5)


## ----echo=TRUE----------------------------------------------------------------
low_density_hex <- find_low_dens_hex(
  model_2d = df_bin_centroids, 
  b1 = 21, 
  md_thresh = 0.05
)


## ----echo=TRUE----------------------------------------------------------------
df_bin_centroids <- df_bin_centroids |>
  dplyr::filter(n_h > 0)

trimesh <- trimesh |>
  dplyr::filter(from_count > 0,
                to_count > 0)

trimesh <- update_trimesh_index(trimesh)


## ----echo=TRUE----------------------------------------------------------------
df_bin <- avg_highd_data(
  highd_data = scurve, 
  scaled_nldr_hexid = hb_obj$data_hb_id
)

head(df_bin, 5)


## ----echo=TRUE----------------------------------------------------------------
predict_data <- predict_emb(
  highd_data = scurve, 
  model_2d = df_bin_centroids, 
  model_highd = df_bin
  )

head(predict_data, 5)


## ----echo=TRUE----------------------------------------------------------------
glance(
  x = scurve_model_obj,
  highd_data = scurve
)


## ----echo=TRUE----------------------------------------------------------------
model_error <- augment(
  x = scurve_model_obj,
  highd_data = scurve
)


## ----echo=TRUE----------------------------------------------------------------
full_hexgrid <- ggplot() + 
  geom_hexgrid(
    data = hb_obj$centroids, 
    aes(x = c_x, y = c_y)
    ) 


## ----echo=TRUE----------------------------------------------------------------
data_hexgrid <- ggplot() + 
  geom_hexgrid(
    data = df_bin_centroids, 
    aes(x = c_x, y = c_y)
    ) 


## ----echo=TRUE----------------------------------------------------------------
full_triangulation_grid <- ggplot() + 
  geom_trimesh(
    data = hb_obj$centroids, 
    aes(x = c_x, y = c_y)
    ) 


## ----echo=TRUE----------------------------------------------------------------
data_triangulation_grid <- ggplot() + 
  geom_trimesh(
    data = df_bin_centroids, 
    aes(x = c_x, y = c_y)
    ) 


## -----------------------------------------------------------------------------

full_hexgrid <- full_hexgrid + 
  xlim(c(-0.2, 1.32)) +
  ylim(c(-0.2, 1.32)) + interior_annotation("a", cex = 3)

data_hexgrid <- data_hexgrid + 
  interior_annotation("b", cex = 3)

full_triangulation_grid <- full_triangulation_grid + 
  xlim(c(-0.2, 1.32)) +
  ylim(c(-0.2, 1.32)) + interior_annotation("c", cex = 3)

data_triangulation_grid <- data_triangulation_grid + 
  interior_annotation("d", cex = 3)



## ----geom-outputs, fig.cap="The outputs of `geom_hexgrid` and `geom_trimesh` include: (a) a complete hexagonal grid, (b) a hexagonal grid that corresponds with the data, (c) a full grid based on centroid triangulation, and (d) a centroid triangulation grid that aligns with the data.", fig.align='center', fig.pos="!ht", fig.height=5, fig.width=20, eval=knitr::is_html_output(), fig.alt = "The figure consists of four 2-D panels illustrating hexagonal grids and triangulated meshes. Panel (a) shows a complete hexagonal grid covering a rectangular 2-D region, with all hexagons drawn regardless of whether data are present. Panel (b) shows a hexagonal grid restricted to bins that contain data points, with only those hexagons displayed and gaps where bins are empty. Panel (c) shows a full triangulated mesh constructed from centroids across the entire grid region, with centroids connected by straight line segments to form triangles. Panel (d) shows a triangulated mesh constructed only from centroids corresponding to non-empty bins, aligned with the data layout and leaving open areas where no centroids are present. In all panels, the horizontal and vertical axes represent continuous 2-D coordinates with bounded numeric ranges, and the grids and meshes are drawn with uniform line styles and colors."----
# 
# full_hexgrid + data_hexgrid +
#   full_triangulation_grid + data_triangulation_grid +
#   plot_layout(ncol = 4)


## ----geom-outputs-pdf, fig.cap="The outputs of \\texttt{geom\\_hexgrid} and \\texttt{geom\\_trimesh} include: (a) a complete hexagonal grid, (b) a hexagonal grid that corresponds with the data, (c) a full grid based on centroid triangulation, and (d) a centroid triangulation grid that aligns with the data.", fig.align='center', fig.pos="!ht", fig.height=5, fig.width=20, eval=knitr::is_latex_output(), fig.alt = "The figure consists of four 2-D panels illustrating hexagonal grids and triangulated meshes. Panel (a) shows a complete hexagonal grid covering a rectangular 2-D region, with all hexagons drawn regardless of whether data are present. Panel (b) shows a hexagonal grid restricted to bins that contain data points, with only those hexagons displayed and gaps where bins are empty. Panel (c) shows a full triangulated mesh constructed from centroids across the entire grid region, with centroids connected by straight line segments to form triangles. Panel (d) shows a triangulated mesh constructed only from centroids corresponding to non-empty bins, aligned with the data layout and leaving open areas where no centroids are present. In all panels, the horizontal and vertical axes represent continuous 2-D coordinates with bounded numeric ranges, and the grids and meshes are drawn with uniform line styles and colors."----

 full_hexgrid + 
  data_hexgrid +  
  full_triangulation_grid + 
  data_triangulation_grid +
  plot_layout(ncol = 4)


## ----echo=TRUE----------------------------------------------------------------
df_exe <- comb_data_model(
  highd_data = scurve, 
  model_highd = df_bin, 
  model_2d = df_bin_centroids
  )


## ----scurve-highd-model-html, echo=TRUE, eval=knitr::is_html_output(), fig.pos="!ht", fig.width=20, fig.height=5, fig.cap="\\texttt{langevitour} output of the lifted high-dimensional wireframe model from the \\texttt{scurve} UMAP layout. These views illustrate how the lifted wireframe model captures the structure of the \\texttt{scurve} data. Regions with sparse or no data in the UMAP layout are also visible in the lifted model.", fig.alt = "The figure shows an animated langevitour of the lifted high-dimensional wireframe model derived from the scurve UMAP layout. At each moment, a 2-D projection is displayed in which the horizontal and vertical axes represent linear combinations of the original high-dimensional coordinates, with continuous numeric ranges. The wireframe model appears as a network of connected line segments drawn in black, while the scurve data points are overlaid in blue as individual markers. As the projection changes smoothly over time, the wireframe and data rotate and change orientation together, revealing different alignments between the model and the data. In some views, parts of the wireframe extend into areas with few or no data points, leaving visible gaps. The display maintains a roughly square aspect ratio throughout the tour."----
# 
# show_langevitour(
#   point_data = df_exe,
#   edge_data = trimesh
#   )


## ----scurve-highd-model-pdf, eval=knitr::is_latex_output(), fig.pos="!ht", fig.cap="$2\\text{-}D$ projections of the lifted high-dimensional wireframe model from the \\texttt{scurve} UMAP layout. Each panel (a1–a4) shows the model (black) overlaid on \\texttt{scurve} data (blue) in different projections. These views illustrate how the lifted wireframe model captures the structure of the \\texttt{scurve} data. Regions with sparse or no data in the UMAP layout are also visible in the lifted model.", fig.alt = "The figure shows four panels of 2-D scatter plots (a1–a4), each displaying a different projection of the lifted high-dimensional wireframe model derived from the scurve UMAP layout. In each panel, the horizontal and vertical axes represent two projected coordinates with continuous numeric ranges. The wireframe model is drawn in black as a wireframe of connected line segments, and the scurve data points are overlaid in blue as individual markers. The relative positions and orientations of the wireframe and data points vary across panels as different projections are shown. In some regions, the wireframe extends into areas with few or no data points, leaving visible gaps between the model and the data. All panels have similar aspect ratios and use consistent color and symbol encodings to distinguish the model from the data."----

scurve_proj_umap_model1 + scurve_proj_umap_model2 + 
  scurve_proj_umap_model3 + scurve_proj_umap_model4 + 
  plot_layout(ncol = 4)


## ----scurve-highd-model-detourrpdf, out.width=c("50%", "50%"), fig.cap="Screenshots of the lifted high-dimensional wireframe model from the \\texttt{scurve} UMAP layout using \\texttt{detourr}. Regions with sparse or no data in the UMAP layout are also visible in the lifted model.", fig.alt = "The figure shows several screenshots of 2-D projections of the lifted high-dimensional wireframe model derived from the scurve UMAP layout using detourr. In each screenshot, the horizontal and vertical axes represent projected coordinates with continuous numeric ranges. The wireframe model is displayed as a set of connected line segments, and the scurve data points are shown as individual markers overlaid on the wireframe. The orientation and shape of the wireframe and point cloud differ across screenshots as different projections are shown. In some views, parts of the wireframe extend into areas with few or no data points, leaving visible gaps between the model and the data. All screenshots use consistent color and line styles and have similar aspect ratios.", fig.pos="H", fig.show='hold', eval=knitr::is_latex_output()----

knitr::include_graphics(c("figures/model_proj1_detourr.png",
                          "figures/model_proj2_detourr.png"))


## ----scurve-highd-model-detourrhtml, echo=TRUE, eval=knitr::is_html_output(), fig.cap="`detourr` output of the lifted high-dimensional wireframe model from the `scurve` UMAP layout. These views illustrate how the lifted wireframe model captures the structure of the `scurve` data. Regions with sparse or no data in the UMAP layout are also visible in the lifted model.", fig.alt = "The figure shows an animated detourr tour of the lifted high-dimensional wireframe model derived from the scurve UMAP layout. The display presents a sequence of changing 2-D projections, where the horizontal and vertical axes represent linear combinations of the original high-dimensional coordinates with continuous numeric ranges. The wireframe model appears as a network of connected line segments, and the scurve data points are overlaid as individual markers. As the tour progresses, the orientation and shape of the wireframe and point cloud change smoothly, revealing different alignments between the model and the data. In some views, sections of the wireframe extend into regions with few or no data points, leaving visible gaps. The visualization maintains a roughly square aspect ratio and consistent visual encodings throughout the tour."----
# 
# detour(
#   df_exe,
#   tour_aes(
#     projection = starts_with("x"),
#     colour = type
#   )
# ) |>
#   tour_path(grand_tour(2),
#                     max_bases=50, fps = 60) |>
#   show_scatter(axes = TRUE, size = 1.5, alpha = 0.5,
#                edges = as.matrix(trimesh[, c("from_reindexed", "to_reindexed")]),
#                palette = c("#66B2CC", "#FF7755"),
#                width = "600px", height = "600px")


## ----echo=TRUE----------------------------------------------------------------
df_exe <- comb_all_data_model(
  highd_data = scurve, 
  nldr_data = scurve_umap, 
  model_highd = df_bin, 
  model_2d = df_bin_centroids
  )


## ----scurve-nldrlink-html, echo=TRUE, eval=knitr::is_html_output(), fig.cap="Interactively linked plots connecting the UMAP layout (left) and the fitted model overlaid with the data in $7\\text{-}D$ (right) using `langevitour`. Brushing in either view highlights the corresponding subset of points across both representations, allowing examination of how well the UMAP layout preserves the underlying `scurve` structure. Double-clicking on either view clears the selection and dehighlights all points.", fig.alt = "The figure shows two interactively linked panels. The left panel displays a 2-D UMAP layout of the scurve data, with horizontal and vertical axes representing the UMAP coordinates on continuous numeric scales. The right panel shows a 2-D projection of the 7-D data and fitted model using langevitour, where each axis represents a linear combination of the original seven dimensions. Data points are plotted as individual markers, and brushing a subset of points in either panel highlights the corresponding points in the other panel using a distinct color. The highlighted points update dynamically as selections change, and double-clicking on either panel clears all highlights. The display maintains roughly square aspect ratios in both panels and uses consistent visual encodings for data and selected subsets throughout the interactive view.", layout = "l-body"----
# 
# nldrdt_link <- show_link_plots(
#   point_data = df_exe,
#   edge_data = trimesh,
#   point_colour = clr_choice
#   )
# 
# nldrdt_link <- crosstalk::bscols(
#     htmltools::div(
#         style = "display: grid; grid-template-columns: 1fr 1fr;
#     gap: 0px; align-items: start; justify-items: center; margin: 0; padding: 0;
#     height: 380px; width: 500px",
#         nldrdt_link
#     ),
#     device = "xs"
# )
# 
# class(nldrdt_link) <- c(class(nldrdt_link), "htmlwidget")
# 
# nldrdt_link


## -----------------------------------------------------------------------------
## Create the first row of selection
scurve_umap_scaled_select1 <- scurve_umap_scaled |>
  mutate(select_area = if_else(emb1 <= 0.7 & emb1 >= 0.4 & emb2 <= 0.25 & emb2 >= 0, "selected", "deselected"))

scurve_umap_scaled_select1_selected <- scurve_umap_scaled_select1 |>
  filter(select_area == "selected")

scurve_umap_scaled_select1_deselected <- scurve_umap_scaled_select1 |>
  filter(select_area == "deselected")

scurve_umap_plt_select1 <- ggplot(
  scurve_umap_scaled_select1_deselected, 
  aes(x = emb1, y = emb2)) +
  geom_point(alpha = 0.5, color = clr_choice, size = 0.5) +
  geom_point(data = scurve_umap_scaled_select1_selected, aes(x = emb1, y = emb2), alpha = 0.5, color = "#756bb1", size = 0.5) +
  xlim(sc_xlims) +
  ylim(sc_ylims)

scurve_umap_plt_select1_lk <- scurve_umap_plt_select1 +
  interior_annotation("a1", cex = 3)

scurve_umap_plt_select1_lk2 <- scurve_umap_plt_select1 +
  interior_annotation("a2", cex = 3) 

proj_obj2_cp[["cluster"]] <- factor(scurve_umap_scaled_select1$select_area,
                                 levels=c("deselected", "selected"))

projected_df <- proj_obj2_cp$projected_df
model_df <- proj_obj2_cp$model_df
axes <- proj_obj2_cp$axes
circle <- proj_obj2_cp$circle

projected_df <- projected_df |>
  dplyr::mutate(cluster = proj_obj2_cp$cluster)

scurve_proj_umap_model1_selected1 <- ggplot() +
      geom_point(
        data = projected_df,
        aes(
          x = proj1,
          y = proj2,
          colour = factor(cluster, levels = c("deselected", "selected")),
          size = factor(cluster, levels = c("deselected", "selected"))),
        alpha = 0.5) +
      geom_segment(
        data = model_df,
        aes(
          x = proj1_from,
          y = proj2_from,
          xend = proj1_to,
          yend = proj2_to),
        colour = "#000000",
        linewidth = 0.5,
        alpha = 0.3) +
      geom_segment(
          data=axes,
          aes(x=x1, y=y1, xend=x2, yend=y2),
          colour="grey70") +
        geom_text(
          data=axes,
          aes(x=x2, y=y2),
          label=rownames(axes),
          colour="grey50",
          size = 5) +
        geom_path(
          data=circle,
          aes(x=c1, y=c2), colour="grey70") +
        xlim(c(-0.5, 0.47)) +
        ylim(c(-0.5, 0.47)) +
  interior_annotation(label = "a2", cex = 3) +
  scale_color_manual(values = c(clr_choice, '#756bb1')) +
  scale_size_manual(values = c('deselected' = 1.0, 'selected' = 1.5)) +
  theme(aspect.ratio = 1,
        legend.position = "none")

scurve_proj_umap_model1_selected1_dp <- ggplot() +
      geom_point(
        data = projected_df,
        aes(
          x = proj1,
          y = proj2,
          colour = factor(cluster, levels = c("deselected", "selected")),
          size = factor(cluster, levels = c("deselected", "selected"))),
        alpha = 0.5) +
      geom_segment(
        data = model_df,
        aes(
          x = proj1_from,
          y = proj2_from,
          xend = proj1_to,
          yend = proj2_to),
        colour = "#000000",
        linewidth = 0.5,
        alpha = 0.3) +
      geom_segment(
          data=axes,
          aes(x=x1, y=y1, xend=x2, yend=y2),
          colour="grey70") +
        geom_text(
          data=axes,
          aes(x=x2, y=y2),
          label=rownames(axes),
          colour="grey50",
          size = 5) +
        geom_path(
          data=circle,
          aes(x=c1, y=c2), colour="grey70") +
        xlim(c(-0.5, 0.47)) +
        ylim(c(-0.5, 0.47)) +
  interior_annotation(label = "a3", cex = 3) +
  scale_color_manual(values = c(clr_choice, '#756bb1')) +
  scale_size_manual(values = c('deselected' = 1.0, 'selected' = 1.5)) +
  theme(aspect.ratio = 1,
        legend.position = "none")

## Create the second row of selection
scurve_umap_scaled_select2 <- scurve_umap_scaled |>
  mutate(select_area = if_else(emb1 <= 0.55 & emb1 >= 0.25 & emb2 <= 1.25 & emb2 >= 0.75, "selected", "deselected"))

scurve_umap_scaled_select2_selected <- scurve_umap_scaled_select2 |>
  filter(select_area == "selected")

scurve_umap_scaled_select2_deselected <- scurve_umap_scaled_select2 |>
  filter(select_area == "deselected")

scurve_umap_plt_select2 <- ggplot(
  scurve_umap_scaled_select2_deselected, 
  aes(x = emb1, y = emb2)) +
  geom_point(alpha = 0.5, color = clr_choice, size = 0.5) +
  geom_point(data = scurve_umap_scaled_select2_selected, aes(x = emb1, y = emb2), alpha = 0.5, color = "#756bb1", size = 0.5) +
  xlim(sc_xlims) +
  ylim(sc_ylims)

scurve_umap_plt_select2_lk <- scurve_umap_plt_select2 +
    interior_annotation("b1", cex = 3) 

scurve_umap_plt_select2_lk2 <- scurve_umap_plt_select2 +
    interior_annotation("b2", cex = 3) 

proj_obj2_cp[["cluster"]] <- factor(scurve_umap_scaled_select2$select_area,
                                 levels=c("deselected", "selected"))

projected_df <- proj_obj2_cp$projected_df
model_df <- proj_obj2_cp$model_df
axes <- proj_obj2_cp$axes
circle <- proj_obj2_cp$circle

projected_df <- projected_df |>
  dplyr::mutate(cluster = proj_obj2_cp$cluster)

scurve_proj_umap_model1_selected2 <- ggplot() +
      geom_point(
        data = projected_df,
        aes(
          x = proj1,
          y = proj2,
          colour = factor(cluster, levels = c("deselected", "selected")),
          size = factor(cluster, levels = c("deselected", "selected"))),
        alpha = 0.5) +
      geom_segment(
        data = model_df,
        aes(
          x = proj1_from,
          y = proj2_from,
          xend = proj1_to,
          yend = proj2_to),
        colour = "#000000",
        linewidth = 0.5,
        alpha = 0.3) +
      geom_segment(
          data=axes,
          aes(x=x1, y=y1, xend=x2, yend=y2),
          colour="grey70") +
        geom_text(
          data=axes,
          aes(x=x2, y=y2),
          label=rownames(axes),
          colour="grey50",
          size = 5) +
        geom_path(
          data=circle,
          aes(x=c1, y=c2), colour="grey70") +
        xlim(c(-0.5, 0.47)) +
        ylim(c(-0.5, 0.47)) +
  interior_annotation(label = "b2", cex = 3) +
  scale_color_manual(values = c(clr_choice, '#756bb1')) +
  scale_size_manual(values = c('deselected' = 1.0, 'selected' = 1.5)) +
  theme(aspect.ratio = 1,
        legend.position = "none")

scurve_proj_umap_model1_selected2_dp <- ggplot() +
      geom_point(
        data = projected_df,
        aes(
          x = proj1,
          y = proj2,
          colour = factor(cluster, levels = c("deselected", "selected")),
          size = factor(cluster, levels = c("deselected", "selected"))),
        alpha = 0.5) +
      geom_segment(
        data = model_df,
        aes(
          x = proj1_from,
          y = proj2_from,
          xend = proj1_to,
          yend = proj2_to),
        colour = "#000000",
        linewidth = 0.5,
        alpha = 0.3) +
      geom_segment(
          data=axes,
          aes(x=x1, y=y1, xend=x2, yend=y2),
          colour="grey70") +
        geom_text(
          data=axes,
          aes(x=x2, y=y2),
          label=rownames(axes),
          colour="grey50",
          size = 5) +
        geom_path(
          data=circle,
          aes(x=c1, y=c2), colour="grey70") +
        xlim(c(-0.5, 0.47)) +
        ylim(c(-0.5, 0.47)) +
  interior_annotation(label = "b3", cex = 3) +
  scale_color_manual(values = c(clr_choice, '#756bb1')) +
  scale_size_manual(values = c('deselected' = 1.0, 'selected' = 1.5)) +
  theme(aspect.ratio = 1,
        legend.position = "none")


## ----scurve-nldrlink-pdf, eval=knitr::is_latex_output(), fig.pos="!ht", fig.width=10, fig.height=10, fig.cap="Exploring the correspondence between UMAP layout and \\texttt{scurve} structure in $7\\text{-}D$. Two sets of plots are interactively linked: UMAP layout (a1, b1) and projection of $7\\text{-}D$ model and data (a2, b2). The purple points indicate the selected subsets, which differ between rows. In (a1), the lower bridge of the \\texttt{scurve} is highlighted, which corresponds in (a2) to points spanning across both arms of the high-dimensional structure. In (b1), a different region near the upper arm of the \\texttt{scurve} is selected, and in (b2) these points map onto one side of the curved manifold in $7\\text{-}D$ projection. While the UMAP layout suggests distinct local clusters, the linked tour views reveal how these selections trace continuous structures in the $7\\text{-}D$ space, highlighting distortions introduced by UMAP.", fig.alt = "The figure consists of four linked panels arranged in two rows and two columns. Panels (a1) and (b1) show 2-D scatter plots of a UMAP layout, with the horizontal and vertical axes representing the two UMAP coordinates on continuous numeric scales. Panels (a2) and (b2) show corresponding 2-D projections from a tour of the 7-D data and model, where each axis represents a linear combination of the original seven dimensions. Data points are plotted as individual markers, and selected subsets are highlighted in purple while unselected points appear in a contrasting color. In the top row, a set of points highlighted in the lower region of the UMAP layout in (a1) is linked to highlighted points in the tour view in (a2). In the bottom row, a different highlighted region in the UMAP layout in (b1) is linked to a different set of highlighted points in the tour view in (b2). The linked selections update consistently across panels, showing how the same subsets of observations appear in the UMAP layout and in different projections of the high-dimensional space."----

scurve_umap_plt_select1_lk + scurve_proj_umap_model1_selected1 +
  scurve_umap_plt_select2_lk + scurve_proj_umap_model1_selected2 +
  plot_layout(ncol = 2)


## ----echo=TRUE----------------------------------------------------------------
df_exe <- comb_all_data_model_error(
  highd_data = scurve, 
  nldr_data = scurve_umap, 
  model_highd = df_bin, 
  model_2d = df_bin_centroids, 
  error_data = model_error
  )


## ----scurve-linkerror-html, echo=TRUE, eval=knitr::is_html_output(), fig.cap="Interactively linked plots connecting the residual distribution (left), the UMAP layout (middle) and the fitted model overlaid with the data in $7\\text{-}D$ (right) using `langevitour`. Brushing in any view highlights the corresponding subset across all panels, allowing detailed inspection of how residuals relate to both the UMAP embedding and the $p\\text{-}D$ structure. Points with higher residuals typically correspond to sparse or bridging regions in the UMAP layout and the less dense ends of the `scurve`, whereas low-residual points tend to cluster within denser, well-preserved regions. Double-clicking clears the selection and resets all highlights.", fig.alt = "The figure shows three interactively linked panels. The left panel displays a univariate plot of model residuals, with the horizontal axis representing residual values and the vertical axis representing density. The middle panel shows a 2-D UMAP layout of the scurve data, with horizontal and vertical axes representing the two UMAP coordinates. The right panel shows a 2-D projection of the 7-D data and fitted model using langevitour, where each axis represents a linear combination of the original dimensions. Points are plotted as individual markers in all panels, and brushing a subset of points in any panel highlights the corresponding points across the other two panels using a distinct color. Selections update dynamically as the user interacts with any panel, and double-clicking clears all highlights. All panels maintain roughly square aspect ratios and consistent visual encodings for selected and unselected points throughout the interactive view.", layout = "l-body"----
# 
# errornldrdt_link <- show_error_link_plots(
#   point_data = df_exe,
#   edge_data = trimesh,
#   point_colour = clr_choice
# )
# 
# class(errornldrdt_link) <- c(class(errornldrdt_link), "htmlwidget")
# 
# errornldrdt_link


## -----------------------------------------------------------------------------
model_error <- model_error |>
  bind_cols(scurve_umap_scaled |>
              select(-ID))

model_error <- model_error |>
  mutate(sqrt_row_wise_total_error = sqrt(row_wise_total_error))

# Compute density
density_data <- density(model_error$sqrt_row_wise_total_error)
density_df <- data.frame(x = density_data$x, y = density_data$y)

# Add density values to the original dataset
model_error <- model_error |>
  mutate(density = approx(density_df$x, density_df$y, xout = sqrt_row_wise_total_error)$y)

## Create the first row of selection
model_error_select1 <- model_error |>
  mutate(select_area = if_else(emb1 <= 0.7 & emb1 >= 0.4 & emb2 <= 0.25 & emb2 >= 0, "selected", "deselected"))

model_error_select1_selected <- model_error_select1 |>
  filter(select_area == "selected")

model_error_select1_deselected <- model_error_select1 |>
  filter(select_area == "deselected")

error_plot_scurve_hist1 <- ggplot(model_error_select1_deselected, 
      aes(x = sqrt_row_wise_total_error, 
          y = density)) +
  geom_point(alpha=0.7, colour = "#d9d9d9") +
  geom_point(data = model_error_select1_selected, 
      aes(x = sqrt_row_wise_total_error, 
          y = density),
      alpha=0.7, colour = "#756bb1", size = 3) +
  xlab(paste("residual")) +
  ylab("") +
  interior_annotation("a1", cex = 3) +
  theme_bw() +
  theme(axis.ticks.y = element_blank(),
        axis.title.x = element_text(size = 18),
        axis.text.x = element_text(size = 15),
        axis.text.y = element_blank(),
        aspect.ratio = 1)

## Create the second row of selection
model_error_select2 <- model_error |>
  mutate(select_area = if_else(emb1 <= 0.55 & emb1 >= 0.25 & emb2 <= 1.25 & emb2 >= 0.75, "selected", "deselected"))

model_error_select2_selected <- model_error_select2 |>
  filter(select_area == "selected")

model_error_select2_deselected <- model_error_select2 |>
  filter(select_area == "deselected")

error_plot_scurve_hist2 <- ggplot(model_error_select2_deselected, 
      aes(x = sqrt_row_wise_total_error, 
          y = density)) +
  geom_point(alpha=0.7, colour = "#d9d9d9") +
  geom_point(data = model_error_select2_selected, 
      aes(x = sqrt_row_wise_total_error, 
          y = density),
      alpha=0.7, colour = "#756bb1", size = 3) +
  xlab(paste("residual")) +
  ylab("") +
  interior_annotation("b1", cex = 3) +
  theme_bw() +
  theme(axis.ticks.y = element_blank(),
        axis.title.x = element_text(size = 18),
        axis.text.x = element_text(size = 15),
        axis.text.y = element_blank(),
        aspect.ratio = 1)


## ----scurve-linkerror-pdf, eval=knitr::is_latex_output(), fig.pos="H", fig.width=15, fig.height=10, fig.cap="Exploring residuals in relation to UMAP layouts using a $7\\text{-}D$ \\texttt{scurve} model. Three views are linked: distribution of residuals (a1, b1), UMAP layout (a2, b2), and projection of the $7\\text{-}D$ model with data (a3, b3). The purple points highlight selected subsets of the data, which differ across rows. In the top row (a1–a3), points with higher residuals (a1) are selected, corresponding to the sparse bridging region in the UMAP layout (a2) and the less dense end of the \\texttt{scurve} in the high-dimensional projection (a3). In the bottom row (b1–b3), points with lower residuals (b1) are highlighted, which map to one side of the dense region in the NLDR layout (b2) and to a thicker band of the \\texttt{scurve} in the projection (b3). This comparison illustrates how residuals can help diagnose distortions in UMAP, with high-residual points often concentrated in sparse or stretched regions of the structure.", fig.alt = "The figure consists of six panels arranged in two rows and three columns, showing residuals and their correspondence between UMAP and high-dimensional projections of the scurve data. In each row, the left panel (a1, b1) is a univariate plot of model residuals, with the horizontal axis representing residual values and the vertical axis representing frequency or density; points selected for highlighting appear in purple. The middle panel (a2, b2) shows a 2-D UMAP layout, with horizontal and vertical axes representing the two UMAP coordinates; the selected points from the left panel are highlighted in purple, while unselected points appear in a contrasting color. The right panel (a3, b3) shows a 2-D projection of the 7-D data and model using a tour view, where axes represent linear combinations of the original dimensions; highlighted points correspond to those selected in the residuals and UMAP panels, while unselected points are shown in a contrasting color. Across the panels, the purple highlights differ between the top and bottom rows, showing different subsets of points. All panels maintain roughly square aspect ratios and use consistent visual encodings for selection and non-selection."----

error_plot_scurve_hist1 + scurve_umap_plt_select1_lk2 + scurve_proj_umap_model1_selected1_dp +
  error_plot_scurve_hist2 + scurve_umap_plt_select2_lk2 + scurve_proj_umap_model1_selected2_dp +
  plot_layout(ncol = 3)


## -----------------------------------------------------------------------------
#| label: read-limb-nldr
# Read a variety of different NLDR representations of limb
# and plot them on same aspect ratio

tsne_limb <- read_rds("data/limb_muscles/facs_limb_muscles_tsne_perplexity_30.rds")

nldr1 <- tsne_limb |>
  ggplot(aes(x = emb1,
             y = emb2)) +
  geom_point(alpha=0.1, size=1, colour='#a65628') +
  interior_annotation("a")

umap_limb <- read_rds("data/limb_muscles/facs_limb_muscles_umap_n-neigbors_15_min-dist_0.1.rds")

nldr2 <- umap_limb |>
  ggplot(aes(x = emb1,
             y = emb2)) +
  geom_point(alpha=0.1, size=1, colour='#999999') +
  interior_annotation("b")

phate_limb <- read_rds("data/limb_muscles/facs_limb_muscles_phate_knn_5.rds")

nldr3 <- phate_limb |>
  ggplot(aes(x = emb1,
             y = emb2)) +
  geom_point(alpha=0.1, size=1, colour='#e41a1c') +
  interior_annotation("c")

trimap_limb <- read_rds("data/limb_muscles/facs_limb_muscles_trimap_n-inliers_12_n-outliers_4_n-random_3.rds")

nldr4 <- trimap_limb |>
  ggplot(aes(x = emb1,
             y = emb2)) +
  geom_point(alpha=0.1, size=1, colour='#984ea3') +
  interior_annotation("d")

pacmap_limb <- read_rds("data/limb_muscles/facs_limb_muscles_pacmap_n-neighbors_10_init_random_MN-ratio_0.5_FP-ratio_2.rds")

nldr5 <- pacmap_limb |>
  ggplot(aes(x = emb1,
             y = emb2)) +
  geom_point(alpha=0.1, size=1, colour='#4daf4a') +
  interior_annotation("e")

tsne_limb2 <- read_rds("data/limb_muscles/facs_limb_muscles_tsne_perplexity_15.rds")

nldr6 <- tsne_limb2 |>
  ggplot(aes(x = emb1,
             y = emb2)) +
  geom_point(alpha=0.1, size=1, colour='#ff7f00') +
  interior_annotation("f")


## -----------------------------------------------------------------------------
#| label: combine-error-data-muscles

error_limb_umap <- read_rds("data/limb_muscles/error_limb_muscles_umap_n-neigbors_15_min-dist_0.1.rds")
error_limb_tsne <- read_rds("data/limb_muscles/error_limb_muscles_tsne_perplexity_30.rds")
error_limb_phate <- read_rds("data/limb_muscles/error_limb_muscles_phate_knn_5.rds")
error_limb_trimap <- read_rds("data/limb_muscles/error_limb_muscles_trimap_n-inliers_12_n-outliers_4_n-random_3.rds")
error_limb_pacmap <- read_rds("data/limb_muscles/error_limb_muscles_pacmap_n-neighbors_10_init_random_MN-ratio_0.5_FP-ratio_2.rds")

error_limb_tsne2 <- read_rds("data/limb_muscles/error_limb_muscles_tsne_perplexity_15.rds")

error_limb <- bind_rows(error_limb_umap, 
                        error_limb_tsne,
                        error_limb_phate,
                        error_limb_trimap,
                        error_limb_pacmap,
                        error_limb_tsne2)

error_limb <- error_limb |>
  mutate(a1 = round(a1, 2)) |>
  filter(b1 >= 5) |>
  filter(a1 >= 0.03) |>
  group_by(method, a1) |>
  filter(HBE == min(HBE)) |>
  ungroup()

error_limb <- error_limb |>
  mutate(method = factor(method,
                         levels = c("tsne_30", "UMAP_15_min_dist_0.1", "phate_5", "trimap_n-inliers_12_n-outliers_4_n-random_3", "pacmap_n-neighbors_10_init_random_MN-ratio_0.5_FP-ratio_2", "tsne_15")))


## -----------------------------------------------------------------------------
#| label: error-comp-muscles

error_plot_limb <- plot_hbe(error_limb) +
  scale_x_continuous(breaks = sort(unique(error_limb$a1))[c(1, 5, 9, 13, 17, 21, 26)]) +
  scale_color_manual(values=c('#a65628','#999999','#e41a1c','#984ea3','#4daf4a','#ff7f00')) 



## ----limb-hbe, fig.cap="Assessing which of the 6 NLDR layouts on the limb muscle data is the better representation using HBE for varying binwidth ($a_1$). Color used for the lines and points in the left plot and in the scatterplots represents NLDR layout (a-f). Layout d performs well at large binwidth (where the binwidth is not enough to capture the data structure) and poorly as the bin width decreases. Layout f is the best choice.\\label{fig:limb-hbe}", fig.alt = "A multi-panel figure shows five alternative 2D embeddings of the same high-dimensional data, arranged side by side (panels b–f). Each panel is a scatterplot with two unlabeled embedding axes (dimension 1 on the horizontal axis and dimension 2 on the vertical axis, each spanning a similar, roughly symmetric range around zero). Points represent the same set of observations in every panel, plotted with identical color or marker scheme so that corresponding observations can be visually compared across layouts. Panel b shows a UMAP layout (neighbors = 5, minimum distance = 0.1), panel c a PHATE layout (knn = 5), panel d a TriMAP layout (inliers = 12, outliers = 4, random = 3), panel e a PaCMAP layout (neighbors = 10, init = random, MN-ratio = 0.5, FP-ratio = 2), and panel f a tSNE layout (perplexity = 15). Across panels, similar clusters of points appear but are arranged differently in space: some layouts show more clearly separated compact clusters, while others show overlapping or elongated groups, reflecting how each method balances local versus global structure. The accompanying HBE plot (typically a separate panel) summarizes model fit quality for each layout, with one value per method indicating that some embeddings provide a more faithful representation of the original data structure than others.", fig.pos="!ht", echo=TRUE----

design <- gen_design(n_right = 6, ncol_right = 2)

plot_hbe_layouts(plots = list(error_plot_limb, nldr1, 
                             nldr2, nldr3, nldr4, 
                             nldr5, nldr6), design = design)


## ----data-limb----------------------------------------------------------------
data_limb <- read_rds("data/limb_muscles/facs_limb_muscles_pcs_10.rds")

cluster_df <- read_rds("data/limb_muscles/facs_limb_muscles_cluster_df.rds")


## -----------------------------------------------------------------------------
#| label: tsne-model-limb

tsne_limb_obj <- fit_highd_model(
  highd_data = data_limb, 
  nldr_data = tsne_limb, 
  b1 = 28, 
  q = 0.1, 
  hd_thresh = 0)

df_bin_centroids_limb <- tsne_limb_obj$model_2d
df_bin_limb <- tsne_limb_obj$model_highd
trimesh_data_limb <- tsne_limb_obj$trimesh_data
tsne_limb_scaled <- tsne_limb_obj$nldr_scaled_obj$scaled_nldr

tsne_limb_scaled_with_cluster <- inner_join(tsne_limb_scaled, cluster_df, by = "ID") |>
  mutate(cluster = as.character(cluster.ids))

trimesh_limb <- ggplot() + 
  geom_point(
    data = tsne_limb_scaled_with_cluster,
    aes(
      x = emb1,
      y = emb2,
      color = cluster
    ),
    alpha = 0.3
  ) +
  geom_segment(data = trimesh_data_limb, 
               aes(
                 x = x_from, 
                 y = y_from, 
                 xend = x_to, 
                 yend = y_to),
               colour = "#000000",
               linewidth = 1,
               alpha = 0.3) +
  scale_color_manual(values = c('#66c2a5','#fc8d62','#8da0cb','#e78ac3','#a6d854','#ffd92f','#a6cee3')) +
  interior_annotation("a1", cex = 2) +
  theme(
    aspect.ratio = 1
  )


## -----------------------------------------------------------------------------

df <- inner_join(data_limb, tsne_limb_scaled_with_cluster, by = "ID")

### Define type column
df <- df |>
  select(starts_with("x"), starts_with("emb"), "cluster") |>
  mutate(type = tsne_limb_scaled_with_cluster$cluster) ## original dataset

df_b <- df_bin_limb |>
  filter(h %in% df_bin_centroids_limb$h) |>
  mutate(type = "model") ## Data with summarized mean

## Reorder the rows of df_b according to the h order in model_2d
df_b <- df_b[match(df_bin_centroids_limb$h, df_b$h),] |>
  tidyr::drop_na() |>
  select(-h)

df_exe_limb_int <- bind_rows(df_b, df)

point_data <- df_exe_limb_int 
edge_data <- trimesh_data_limb

num_highd_col <- point_data |>
  dplyr::select(starts_with("x")) |>
  NCOL()

shared_df <- crosstalk::SharedData$new(point_data)

cluster_colors <- c(
    "0" = '#66c2a5', "1" = '#fc8d62', "2" = '#8da0cb',
    "3" = '#e78ac3', "4" = '#a6d854', "5" = '#ffd92f', "6" = '#a6cee3'
)

point_sizes <- c(0, 1)

# Scatter points
nldr_plt <- plot_ly(
    data = shared_df,
    x = ~emb1, y = ~emb2,
    type = "scatter", mode = "markers",
    color = ~cluster, colors = cluster_colors,
    marker = list(size = 3, opacity = 0.5),
    hoverinfo = "skip",  # <-- skip hover completely
    showlegend = FALSE
)

# Add line segments
nldr_plt <- nldr_plt |>
    add_segments(
        data = trimesh_data_limb,
        x = ~x_from, y = ~y_from,
        xend = ~x_to, yend = ~y_to,
        line = list(color = "#000000", width = 0.5),
        inherit = FALSE,
        showlegend = FALSE,
        hoverinfo = "skip"  # <-- skip hover
    )

# Layout: axes, border, no tooltip
nldr_plt <- nldr_plt |>
    layout(
        width = 310, height = 310,
        margin = list(l = 20, r = 20, t = 20, b = 20),
        xaxis = list(title = "", showgrid = FALSE, zeroline = FALSE,
                     showticklabels = FALSE, ticks = "", linecolor = "black", mirror = TRUE),
        yaxis = list(title = "", showgrid = FALSE, zeroline = FALSE,
                     showticklabels = FALSE, ticks = "", linecolor = "black", mirror = TRUE)
    ) |>
    style(
        selected = list(marker = list(opacity = 1)),
        unselected = list(marker = list(opacity = 1))
    ) |>
    highlight(
        on = "plotly_selected",
        off = "plotly_deselect"
    ) |>
    config(displayModeBar = FALSE)


langevitour_output <- langevitour::langevitour(point_data[1:num_highd_col],
                                               lineFrom = edge_data$from_reindexed,
                                               lineTo = edge_data$to_reindexed,
                                               group = factor(point_data$type,
                                                              c("0", "1", "2", "3", "4", "5", "6", "model")),
                                               pointSize = append(rep(point_sizes[1], NROW(df_b)),
                                                                  rep(point_sizes[2], NROW(df))),
                                               levelColors = c('#66c2a5','#fc8d62','#8da0cb','#e78ac3','#a6d854','#ffd92f','#a6cee3', "#000000"),
                                               link=shared_df,
                                               linkFilter=FALSE,
                                               width = "370px", height = "370px")

linked_plt_int <- crosstalk::bscols(
    htmltools::div(
        style = "display: grid; grid-template-columns: 1fr 1fr;
    gap: 0px;
    align-items: start;
    justify-items: center;
    margin: 0;
    padding: 0;
    height: 380px;
    width: 500px",
        nldr_plt, 
        htmltools::div(style = "margin-top: 20px;", langevitour_output)
    ),
    device = "xs"
)



## -----------------------------------------------------------------------------
#| label: prep-limb-tsne-author-model-proj

data_limb_n <- data_limb |> 
  select(-ID) |>
  mutate(type = "data")

df_b_limb <- df_bin_limb |>
  dplyr::filter(h %in% df_bin_centroids_limb$h) |>
  dplyr::mutate(type = "model") ## Data with summarized mean

## Reorder the rows of df_b according to the h order in df_b_with_center_data
df_b_limb <- df_b_limb[match(df_bin_centroids_limb$h, df_b_limb$h),] |>
  dplyr::select(-h) 

# Apply the scaling
df_model_data_limb <- bind_rows(data_limb_n, df_b_limb)
scaled_limb <- center_data(df_model_data_limb[,-11]) |>
  as_tibble() |>
  mutate(type = df_model_data_limb$type)

scaled_limb_data <- scaled_limb |>
  filter(type == "data") |>
  select(-type)

scaled_limb_data_model <- scaled_limb |>
  filter(type == "model") |>
  select(-type)


## ----plot-proj----------------------------------------------------------------

## First projection
projection <- cbind(
  c(-0.021068,0.007018,0.008770,0.016884,-0.008135,0.011458,-0.022323,0.007231,0.004976,-0.019298),
  c(-0.017371,-0.008514,0.003231,-0.022945,-0.026264,-0.001571,0.008007,-0.001268,-0.016923,-0.006700))

proj_obj1 <- get_projection(projection = projection, 
                            highd_data = scaled_limb_data, 
                            model_highd = scaled_limb_data_model, 
                            trimesh_data = trimesh_data_limb, 
                            axis_param = list(limits = 1.5,
                                              axis_scaled = 20, 
                                              axis_pos_x = -1, 
                                              axis_pos_y = -1, 
                                              threshold = 0.13))

proj_obj1[["cluster"]] <- as.character(tsne_limb_scaled_with_cluster$cluster)

limb_proj_tsne_model1 <- plot_proj(
  proj_obj = proj_obj1, 
  point_param = c(1.5, 0.2), # size, alpha, color
  line_param = c(0.5, 0.3, "#000000"),
  plot_limits = c(-1.3, 1.4), 
  axis_text_size = 4,
  is_category = TRUE) +
  interior_annotation(label = "a2", cex = 2) + 
  scale_color_manual(values = c('#66c2a5','#fc8d62','#8da0cb','#e78ac3','#a6d854','#ffd92f','#a6cee3'))

## Second projection
projection <- cbind(
  c(-0.025678,-0.017472,0.015634,-0.014868,-0.000752,0.001050,-0.019524,-0.008076,-0.010808,-0.002319),
  c(0.014526,-0.013526,-0.005147,-0.027612,-0.016919,0.005198,0.010710,0.004623,-0.007055,0.017842))

proj_obj2 <- get_projection(projection = projection, 
                            highd_data = scaled_limb_data, 
                            model_highd = scaled_limb_data_model, 
                            trimesh_data = trimesh_data_limb, 
                            axis_param = list(limits = 1.5,
                                              axis_scaled = 20, 
                                              axis_pos_x = -1, 
                                              axis_pos_y = -1, 
                                              threshold = 0.14))

proj_obj2[["cluster"]] <- as.character(tsne_limb_scaled_with_cluster$cluster)

limb_proj_tsne_model2 <- plot_proj(
  proj_obj = proj_obj2, 
  point_param = c(1.5, 0.2), # size, alpha, color
  line_param = c(0.5, 0.3, "#000000"),
  plot_limits = c(-1.3, 1.3), 
  axis_text_size = 4,
  is_category = TRUE) +
  interior_annotation(label = "a3", cex = 2) + 
  scale_color_manual(values = c('#66c2a5','#fc8d62','#8da0cb','#e78ac3','#a6d854','#ffd92f','#a6cee3'))




## -----------------------------------------------------------------------------
#| label: tsne-best-model-limb

tsne_best_limb_obj <- fit_highd_model(
  highd_data = data_limb, 
  nldr_data = tsne_limb2, 
  b1 = 28, 
  q = 0.1, 
  hd_thresh = 0)

df_bin_centroids_limb <- tsne_best_limb_obj$model_2d
df_bin_limb <- tsne_best_limb_obj$model_highd
trimesh_data_limb <- tsne_best_limb_obj$trimesh_data
tsne_limb_scaled <- tsne_best_limb_obj$nldr_scaled_obj$scaled_nldr

tsne_limb_scaled_with_cluster <- inner_join(tsne_limb_scaled, cluster_df, by = "ID") |>
  mutate(cluster = as.character(cluster.ids))

trimesh_limb_best <- ggplot() + 
  geom_point(
    data = tsne_limb_scaled_with_cluster,
    aes(
      x = emb1,
      y = emb2,
      color = cluster
    ),
    alpha = 0.3
  ) +
  geom_segment(data = trimesh_data_limb, 
               aes(
                 x = x_from, 
                 y = y_from, 
                 xend = x_to, 
                 yend = y_to),
               colour = "#000000",
               linewidth = 1,
               alpha = 0.3) +
  scale_color_manual(values = c('#66c2a5','#fc8d62','#8da0cb','#e78ac3','#a6d854','#ffd92f','#a6cee3')) +
  interior_annotation("f1", cex = 2) +
  theme(
    aspect.ratio = 1
  )



## -----------------------------------------------------------------------------
df <- inner_join(data_limb, tsne_limb_scaled_with_cluster, by = "ID")

### Define type column
df <- df |>
  select(starts_with("x"), starts_with("emb"), "cluster") |>
  mutate(type = tsne_limb_scaled_with_cluster$cluster) ## original dataset

df_b <- df_bin_limb |>
  filter(h %in% df_bin_centroids_limb$h) |>
  mutate(type = "model") ## Data with summarized mean

## Reorder the rows of df_b according to the h order in model_2d
df_b <- df_b[match(df_bin_centroids_limb$h, df_b$h),] |>
  tidyr::drop_na() |>
  select(-h)

df_exe_limb_int <- bind_rows(df_b, df)

point_data <- df_exe_limb_int 
edge_data <- trimesh_data_limb

num_highd_col <- point_data |>
  dplyr::select(starts_with("x")) |>
  NCOL()

shared_df <- crosstalk::SharedData$new(point_data)

cluster_colors <- c(
    "0" = '#66c2a5', "1" = '#fc8d62', "2" = '#8da0cb',
    "3" = '#e78ac3', "4" = '#a6d854', "5" = '#ffd92f', "6" = '#a6cee3'
)

# Scatter points
nldr_plt <- plot_ly(
    data = shared_df,
    x = ~emb1, y = ~emb2,
    type = "scatter", mode = "markers",
    color = ~cluster, colors = cluster_colors,
    marker = list(size = 3, opacity = 0.5),
    hoverinfo = "skip",  # <-- skip hover completely
    showlegend = FALSE
)

# Add line segments
if (nrow(trimesh_data_limb) > 0) {
    nldr_plt <- nldr_plt |>
        add_segments(
            data = trimesh_data_limb,
            x = ~x_from, y = ~y_from,
            xend = ~x_to, yend = ~y_to,
            line = list(color = "#000000", width = 0.5),
            inherit = FALSE,
            showlegend = FALSE,
            hoverinfo = "skip"  # <-- skip hover
        )
}

# Layout: axes, border, no tooltip
nldr_plt <- nldr_plt |>
    layout(
        width = 310, height = 310,
        margin = list(l = 20, r = 20, t = 20, b = 20),
        xaxis = list(title = "", showgrid = FALSE, zeroline = FALSE,
                     showticklabels = FALSE, ticks = "", linecolor = "black", mirror = TRUE),
        yaxis = list(title = "", showgrid = FALSE, zeroline = FALSE,
                     showticklabels = FALSE, ticks = "", linecolor = "black", mirror = TRUE)
    ) |>
    style(
        selected = list(marker = list(opacity = 1)),
        unselected = list(marker = list(opacity = 1))
    ) |>
    highlight(
        on = "plotly_selected",
        off = "plotly_deselect"
    ) |>
    config(displayModeBar = FALSE)


langevitour_output <- langevitour::langevitour(point_data[1:num_highd_col],
                                               lineFrom = edge_data$from_reindexed,
                                               lineTo = edge_data$to_reindexed,
                                               group = factor(point_data$type,
                                                              c("0", "1", "2", "3", "4", "5", "6", "model")),
                                               pointSize = append(rep(point_sizes[1], NROW(df_b)),
                                                                  rep(point_sizes[2], NROW(df))),
                                               levelColors = c('#66c2a5','#fc8d62','#8da0cb','#e78ac3','#a6d854','#ffd92f','#a6cee3', "#000000"),
                                               link=shared_df,
                                               linkFilter=FALSE,
                                               width = "370px", height = "370px")

linked_plt_best <- crosstalk::bscols(
    htmltools::div(
        style = "display: grid; grid-template-columns: 1fr 1fr;
    gap: 0px;
    align-items: start;
    justify-items: center;
    margin: 0;
    padding: 0;
    height: 380px;
    width: 500px",
        nldr_plt, 
        htmltools::div(style = "margin-top: 20px;", langevitour_output)
    ),
    device = "xs"
)


## -----------------------------------------------------------------------------
#| label: prep-limb-tsne-best-model-proj

data_limb_n <- data_limb |> 
  select(-ID) |>
  mutate(type = "data")

df_b_limb <- df_bin_limb |>
  dplyr::filter(h %in% df_bin_centroids_limb$h) |>
  dplyr::mutate(type = "model") ## Data with summarized mean

## Reorder the rows of df_b according to the h order in df_b_with_center_data
df_b_limb <- df_b_limb[match(df_bin_centroids_limb$h, df_b_limb$h),] |>
  dplyr::select(-h) 

# Apply the scaling
df_model_data_limb <- bind_rows(data_limb_n, df_b_limb)
scaled_limb <- center_data(df_model_data_limb[,-11]) |>
  as_tibble() |>
  mutate(type = df_model_data_limb$type)

scaled_limb_data <- scaled_limb |>
  filter(type == "data") |>
  select(-type)

scaled_limb_data_model <- scaled_limb |>
  filter(type == "model") |>
  select(-type)


## ----plot-proj-best-----------------------------------------------------------

## First projection
projection <- cbind(
  c(-0.021068,0.007018,0.008770,0.016884,-0.008135,0.011458,-0.022323,0.007231,0.004976,-0.019298),
  c(-0.017371,-0.008514,0.003231,-0.022945,-0.026264,-0.001571,0.008007,-0.001268,-0.016923,-0.006700))

proj_obj1 <- get_projection(projection = projection, 
                            highd_data = scaled_limb_data, 
                            model_highd = scaled_limb_data_model, 
                            trimesh_data = trimesh_data_limb, 
                            axis_param = list(limits = 1.5,
                                              axis_scaled = 20, 
                                              axis_pos_x = -1, 
                                              axis_pos_y = -1, 
                                              threshold = 0.13))

proj_obj1[["cluster"]] <- as.character(tsne_limb_scaled_with_cluster$cluster)

limb_proj_tsne_best_model1 <- plot_proj(
  proj_obj = proj_obj1, 
  point_param = c(1.5, 0.2), # size, alpha, color
  plot_limits = c(-1.3, 1.4), 
  axis_text_size = 4,
  is_category = TRUE) +
  interior_annotation(label = "f2", cex = 2) + 
  scale_color_manual(values = c('#66c2a5','#fc8d62','#8da0cb','#e78ac3','#a6d854','#ffd92f','#a6cee3'))

## Second projection
projection <- cbind(
  c(-0.025678,-0.017472,0.015634,-0.014868,-0.000752,0.001050,-0.019524,-0.008076,-0.010808,-0.002319),
  c(0.014526,-0.013526,-0.005147,-0.027612,-0.016919,0.005198,0.010710,0.004623,-0.007055,0.017842))

proj_obj2 <- get_projection(projection = projection, 
                            highd_data = scaled_limb_data, 
                            model_highd = scaled_limb_data_model, 
                            trimesh_data = trimesh_data_limb, 
                            axis_param = list(limits = 1.5,
                                              axis_scaled = 20, 
                                              axis_pos_x = -1, 
                                              axis_pos_y = -1, 
                                              threshold = 0.14))

proj_obj2[["cluster"]] <- as.character(tsne_limb_scaled_with_cluster$cluster)

limb_proj_tsne_best_model2 <- plot_proj(
  proj_obj = proj_obj2, 
  point_param = c(1.5, 0.2), # size, alpha, color
  plot_limits = c(-1.3, 1.3), 
  axis_text_size = 4,
  is_category = TRUE) +
  interior_annotation(label = "f3", cex = 2) + 
  scale_color_manual(values = c('#66c2a5','#fc8d62','#8da0cb','#e78ac3','#a6d854','#ffd92f','#a6cee3'))




## ----model-limb, fig.cap="Representative views of two selected NLDR layouts for the Limb muscle dataset ($n=1067$), shown row-wise. The top row (a1–a3) corresponds to the published $2\\text{-}D$ layout (Figure \\ref{fig:limb-hbe}a), and the bottom row (f1–f3) corresponds to the $2\\text{-}D$ layout selected (Figure \\ref{fig:limb-hbe}f) selected using the HBE plot. In each row, the left panel (a1, f1) shows the NLDR embedding with points colored by muscle group and overlaid with triangulated hexagon centroids. The middle (a2, f2) and right (a3, f3) panels show two different $2\\text{-}D$ projections of the fitted model and data in the original $10\\text{-}D$ space, with the same triangular mesh displayed. Together, these panels summarize how the low-dimensional layouts relate to the underlying high-dimensional structure across different viewing directions.", fig.alt = "The figure consists of six panels arranged in two rows and three columns, showing representative views of two NLDR layouts for the Limb muscle dataset (n=1067). In the top row (a1–a3), the left panel (a1) shows the published 2-D NLDR embedding with points colored by muscle group and overlaid with triangulated hexagon centroids. The middle (a2) and right (a3) panels show two different 2-D projections of the corresponding 10-D data and fitted model, with points plotted as individual markers and the same triangular mesh connecting centroids. In the bottom row (f1–f3), the left panel (f1) shows the 2-D NLDR layout selected using the HBE plot, again with colored points and triangulated centroids, while panels (f2) and (f3) show two different 2-D projections of the associated 10-D structure with the same mesh displayed. Across all panels, axes represent continuous numeric coordinates, color encodes muscle group, and the triangular mesh is used consistently to show correspondence between the low-dimensional layouts and the high-dimensional projections.", fig.pos="!ht", fig.width=15, fig.height=10, eval=knitr::is_latex_output()----

trimesh_limb + limb_proj_tsne_model1 +
  limb_proj_tsne_model2 + trimesh_limb_best +
  limb_proj_tsne_best_model1 + limb_proj_tsne_best_model2 +
  plot_layout(nrow = 2)


## ----tsne-link-limb, eval=knitr::is_html_output(), fig.cap="Interactively linked plots connecting layout a (left) and the fitted model overlaid with the limb muscle data in $10\\text{-}D$ (right). Each color represents a different muscle group, with triangulated hexagon centroids on the NLDR layout connected to their corresponding regions in the high-dimensional projection using `langevitour`. Brushing in either view highlights the same subset of points across both panels, enabling exploration of how clusters in the low-dimensional embedding align with structures in the original high-dimensional space. Double-clicking clears the selection and removes highlights.", fig.alt = "The figure shows two interactively linked panels. The left panel displays a 2-D NLDR layout of the Limb muscle dataset (n=1067), with each point representing an observation and colored according to its muscle group. The right panel shows a 2-D projection of the 10-D data and fitted model using langevitour, where each axis represents a linear combination of the original dimensions. Triangulated hexagon centroids on the NLDR layout are connected to their corresponding regions in the high-dimensional projection. Brushing a subset of points in either panel highlights the corresponding points in both panels using a distinct color, and double-clicking clears all selections. Both panels maintain roughly square aspect ratios and consistent visual encodings for selected and unselected points throughout the interactive view.", layout = "l-body"----
# 
# class(linked_plt_int) <- c(class(linked_plt_int), "htmlwidget")
# 
# linked_plt_int


## ----tsne-link-limb-best, eval=knitr::is_html_output(), fig.cap="Interactively linked plots connecting layout f (left) and the fitted model overlaid with the limb muscle data in $10\\text{-}D$ (right). Each color represents a different muscle group, with triangulated hexagon centroids on the NLDR layout connected to their corresponding regions in the high-dimensional projection using `langevitour`. Brushing in either view highlights the same subset of points across both panels, enabling exploration of how clusters in the low-dimensional embedding align with structures in the original high-dimensional space. Double-clicking clears the selection and removes highlights.", fig.alt = "The figure shows two interactively linked panels. The left panel displays a 2-D NLDR layout (layout f) of the Limb muscle dataset (n=1067), with each point representing an observation and colored by muscle group. The right panel shows a 2-D projection of the 10-D data and fitted model using langevitour, where each axis represents a linear combination of the original dimensions. Triangulated hexagon centroids on the NLDR layout are connected to their corresponding regions in the high-dimensional projection. Brushing a subset of points in either panel highlights the same points in both panels using a distinct color, and double-clicking clears all selections. Both panels maintain roughly square aspect ratios and consistent visual encodings for selected and unselected points throughout the interactive view.", layout = "l-body"----
# 
# class(linked_plt_best) <- c(class(linked_plt_best), "htmlwidget")
# 
# linked_plt_best

