# Generated by `rjournal_pdf_article()` using `knitr::purl()`: do not edit by hand
# Please edit paper-quollr.Rmd to modify this file

## ----setup, include=FALSE-----------------------------------------------------
options(repos = "https://cloud.r-project.org") ## set up CRAN mirror
knitr::opts_chunk$set(
  echo = FALSE, 
  cache=FALSE, 
  message=FALSE, 
  warning=FALSE,
  comment = ">",
  out.width = "100%",
  htmlwidgets.sizing = TRUE)



## ----install-libraries, include=FALSE, warning=FALSE, echo=FALSE, eval=FALSE----
# 
# # Ensure remotes is available
# if (!requireNamespace("remotes", quietly = TRUE)) {
#   install.packages("remotes")
# }
# 
# # Read the package list
# pkgs_raw <- readLines("_Rpackages.txt")
# pkgs_raw <- pkgs_raw[nzchar(pkgs_raw)]  # remove empty lines
# 
# # Split into package and version
# parts <- strsplit(pkgs_raw, "==")
# pkgs <- vapply(parts, `[[`, "", 1)
# versions <- vapply(parts, `[[`, "", 2)
# 
# # Install packages with exact versions
# for (i in seq_along(pkgs)) {
#   pkg <- pkgs[i]
#   ver <- versions[i]
# 
#   if (!requireNamespace(pkg, quietly = TRUE) ||
#       as.character(packageVersion(pkg)) != ver) {
# 
#     message(sprintf("Installing %s (%s)", pkg, ver))
#     remotes::install_version(pkg, version = ver, upgrade = "never")
#   }
# }
# 


## ----load-libraries-----------------------------------------------------------
library(quollr)
library(tibble)
library(knitr)
library(kableExtra)
library(ggplot2)
library(dplyr)
library(patchwork)
library(readr)
library(plotly)
library(crosstalk)
library(htmltools)
library(detourr)

set.seed(20240110)


## ----plot-theme---------------------------------------------------------------
theme_set(theme_linedraw() +
   theme(
     aspect.ratio = 1,
     plot.background = element_rect(fill = 'transparent', colour = NA),
     plot.title = element_text(size = 7, hjust = 0.5, vjust = -0.5),
     panel.background = element_rect(fill = 'transparent', 
                                     colour = NA),
     panel.grid.major = element_blank(), 
     panel.grid.minor = element_blank(), 
     axis.title.x = element_blank(), axis.title.y = element_blank(),
     axis.text.x = element_blank(), axis.ticks.x = element_blank(),
     axis.text.y = element_blank(), axis.ticks.y = element_blank(),
     legend.background = element_rect(fill = 'transparent', 
                                      colour = NA),
     legend.key = element_rect(fill = 'transparent', 
                               colour = NA),
     legend.position = "none", 
     legend.title = element_text(size=5), 
     legend.text = element_text(size=4),
     legend.key.height = unit(0.25, 'cm'),
     legend.key.width = unit(0.25, 'cm'),
     plot.margin = margin(0, 0, 0, 0)
   )

)


## -----------------------------------------------------------------------------
#| label: import-scripts
source("scripts/additional_functions.R")


## -----------------------------------------------------------------------------
clr_choice <- "#66B2CC"

scurve_model_obj <- fit_highd_model(
  highd_data = scurve, 
  nldr_data = scurve_umap, 
  b1 = 21, 
  q = 0.1, 
  hd_thresh = 0)

scurve_umap_scaled <- scurve_model_obj$nldr_scaled_obj$scaled_nldr
tr_from_to_df_scurve <- scurve_model_obj$trimesh_data
df_bin_centroids_scurve <- scurve_model_obj$model_2d
df_bin_scurve <- scurve_model_obj$model_highd
hex_grid_scurve <- scurve_model_obj$hb_obj$hex_poly
counts_df_scurve <- scurve_model_obj$hb_obj$std_cts

hex_grid_with_counts_scurve <- left_join(
  hex_grid_scurve, counts_df_scurve, 
  by = c("h" = "h"))

hex_grid_nonempty_scurve <- hex_grid_scurve |>
  filter(h %in% df_bin_centroids_scurve$h)

sc_xlims <- c(-0.25, 1.35)
sc_ylims <- c(-0.25, 1.35)

scurve_umap_plt <- ggplot(
  scurve_umap_scaled, 
  aes(x = emb1, y = emb2)) +
  geom_point(alpha = 0.5, color = clr_choice, size = 0.5) +
  interior_annotation("a", cex = 1) +
  xlim(sc_xlims) +
  ylim(sc_ylims)

scurve_umap_plt_int <- ggplotly(scurve_umap_plt, 
                                width = "350", 
                                height = "350", 
                                tooltip = "none") |>
  config(
    staticPlot = TRUE,        # Disables all interactivity (no hover, zoom, pan)
    displayModeBar = FALSE,   # Hides the plotly toolbar
    editable = FALSE,         # Disables annotations and editing
    showTips = FALSE,         # Removes tooltip on hover
    displaylogo = FALSE,      # Hides plotly logo
    responsive = FALSE        # Disables responsive resizing
  )

hex_grid_poly_scurve <- ggplot(
  data = hex_grid_with_counts_scurve, 
  aes(x = x, y = y)) +
  geom_polygon(color = "grey70", 
               aes(group = h), 
               fill = "#ffffff") +
  geom_point(data = scurve_umap_scaled, 
             aes(x = emb1, y = emb2), 
             alpha = 0.8, size = 0.5, color = clr_choice) + 
  interior_annotation("a", cex = 1) +
  xlim(sc_xlims) +
  ylim(sc_ylims)

hex_grid_poly_scurve_int <- ggplotly(hex_grid_poly_scurve, 
                                width = "400", 
                                height = "380", 
                                tooltip = "none") |>
  config(
    staticPlot = TRUE,        # Disables all interactivity (no hover, zoom, pan)
    displayModeBar = FALSE,   # Hides the plotly toolbar
    editable = FALSE,         # Disables annotations and editing
    showTips = FALSE,         # Removes tooltip on hover
    displaylogo = FALSE,      # Hides plotly logo
    responsive = FALSE        # Disables responsive resizing
  )

hex_centroids_scurve <- ggplot(
  data = hex_grid_with_counts_scurve, 
  aes(x = x, y = y)) +
  geom_polygon(color = "grey70", 
               aes(group = h), 
               fill = "#ffffff")  +
  geom_point(data = df_bin_centroids_scurve, 
             aes(x = c_x, y = c_y), 
             size = 1, color = "#FF7755") +
  interior_annotation("b", cex = 1) +
  xlim(sc_xlims) +
  ylim(sc_ylims)

hex_centroids_scurve_int <- ggplotly(hex_centroids_scurve, 
                                width = "400", 
                                height = "380", 
                                tooltip = "none") |>
  config(
    staticPlot = TRUE,        # Disables all interactivity (no hover, zoom, pan)
    displayModeBar = FALSE,   # Hides the plotly toolbar
    editable = FALSE,         # Disables annotations and editing
    showTips = FALSE,         # Removes tooltip on hover
    displaylogo = FALSE,      # Hides plotly logo
    responsive = FALSE        # Disables responsive resizing
  )

wireframe_scurve <- ggplot() +
  geom_segment(data = tr_from_to_df_scurve,
               aes(
                 x = x_from,
                 y = y_from,
                 xend = x_to,
                 yend = y_to),
               colour = "#000000") +
  geom_point(data = df_bin_centroids_scurve, 
             aes(x = c_x, y = c_y), 
             size = 1, color = "#FF7755") +
  interior_annotation("c", cex = 1) +
  xlim(sc_xlims) +
  ylim(sc_ylims)

wireframe_scurve_int <- plot_ly() |>
    # Wireframe segments
    add_segments(
        data = tr_from_to_df_scurve,
        x = ~x_from, y = ~y_from,
        xend = ~x_to, yend = ~y_to,
        line = list(color = "#000000", width = 0.5),
        hoverinfo = "none",
        showlegend = FALSE
    ) |>
    # Centroid points
    add_markers(
        data = df_bin_centroids_scurve,
        x = ~c_x, y = ~c_y,
        marker = list(size = 4, color = "#FF7755"),
        hoverinfo = "none",
        showlegend = FALSE
    ) |>
    # Layout with border
    layout(
        width = 350,
        height = 320,
        xaxis = list(
            range = sc_xlims,
            showgrid = FALSE,
            zeroline = FALSE,
            showticklabels = FALSE,
            ticks = "",
            title = ""
        ),
        yaxis = list(
            range = sc_ylims,
            showgrid = FALSE,
            zeroline = FALSE,
            showticklabels = FALSE,
            ticks = "",
            title = ""
        ),
        
        # ADD A BOX AROUND THE ENTIRE PLOT PANEL
        shapes = list(
            list(
                type = "rect",
                xref = "paper", yref = "paper",
                x0 = 0, y0 = 0,
                x1 = 1, y1 = 1,
                line = list(color = "black", width = 1)
            )
        )
    ) |>
    config(
        staticPlot = TRUE,
        displayModeBar = FALSE,
        editable = FALSE,
        showTips = FALSE,
        displaylogo = FALSE,
        responsive = FALSE
    )

## 2-d vis model
hex_grid_scurve <- ggplot(
  data = hex_grid_with_counts_scurve, 
  aes(x = x, y = y)) +
  geom_point(data = scurve_umap_scaled, 
             aes(x = emb1, y = emb2), 
             size = 0.5, color = clr_choice) +
  geom_segment(data = tr_from_to_df_scurve,
               aes(
                 x = x_from,
                 y = y_from,
                 xend = x_to,
                 yend = y_to),
               colour = "#000000") +
  geom_point(data = df_bin_centroids_scurve, 
             aes(x = c_x, y = c_y), 
             size = 1, color = "#FF7755")

hex_grid_scurve_int <- ggplotly(hex_grid_scurve, 
                                width = "350", 
                                height = "380", 
                                tooltip = "none") |>
  config(
    staticPlot = TRUE,        # Disables all interactivity (no hover, zoom, pan)
    displayModeBar = FALSE,   # Hides the plotly toolbar
    editable = FALSE,         # Disables annotations and editing
    showTips = FALSE,         # Removes tooltip on hover
    displaylogo = FALSE,      # Hides plotly logo
    responsive = FALSE        # Disables responsive resizing
  )


## High-d vis model
df_exe <- comb_data_model(
    highd_data = scurve, 
    model_highd = df_bin_scurve, 
    model_2d = df_bin_centroids_scurve
)

df <- df_exe |>
    dplyr::filter(type == "data") ## original dataset

df_b <- df_exe |>
  dplyr::filter(type == "model") ## High-d model

scurve_umap_model_vis <- langevitour::langevitour(df_exe[1:(length(df_exe)-1)],
                         lineFrom = tr_from_to_df_scurve$from_reindexed,
                         lineTo = tr_from_to_df_scurve$to_reindexed,
                         group = df_exe$type,
                         pointSize = append(rep(2, NROW(df_b)), rep(1, NROW(df))),
                         levelColors = c(clr_choice, "#FF7755"),
                         enableControls = FALSE,
                         width = "400px", height = "380px")

scurve_umap_model_vis_n <- langevitour::langevitour(df_exe[1:(length(df_exe)-1)],
                         lineFrom = tr_from_to_df_scurve$from_reindexed,
                         lineTo = tr_from_to_df_scurve$to_reindexed,
                         group = df_exe$type,
                         pointSize = append(rep(2, NROW(df_b)), rep(1, NROW(df))),
                         levelColors = c(clr_choice, "#FF7755"),
                         enableControls = FALSE,
                         width = "400px", height = "550px")



## ----overviewhtml, eval=knitr::is_html_output(), fig.cap="Wireframe model representation of the NLDR layout, lifted and displayed in high-dimensional space. The left panel shows the NLDR layout with a triangular mesh overlay, forming the wireframe structure. This mesh can be lifted into higher dimensions and projected to examine how the geometric structure of the data is preserved. Panels (a1–a4) display different $2\\text{-}D$ projections of the lifted wireframe, where the underlying curved sheet structure of the data is more clearly visible. The triangulated mesh highlights how local neighborhoods in the layout correspond to relationships in the high-dimensional space, enabling diagnostics of distortion and preservation across dimensions.", fig.pos="!ht", layout = "l-body", fig.alt="The UMAP layout with a triangular mesh on the left and 2-D projections of the lifted wireframe overlaying the data on the right. The mesh illustrates how local neighborhoods in the 2-D embedding correspond to curved sheet structures in the original high-dimensional S-curve data."----
# 
# overviewfig <- bscols(
#   htmltools::div(
#     style = "
#       display: flex;
#       justify-content: center;  /* centers the whole grid */
#       margin: 0 auto;
#       padding: 0;
#     ",
#     htmltools::div(
#       style = "
#         display: grid;
#         grid-template-columns: 1fr 1fr;
#         gap: 0px;
#         align-items: start;
#         justify-items: center;
#         margin: 0;
#         padding: 0;
#       ",
#       htmltools::div(style = "margin: 0; padding: 0;", hex_grid_scurve_int),
#       htmltools::div(style = "margin: 0; margin-top: 13px; padding: 0;", scurve_umap_model_vis)
#     )
#   ),
#   device = "xs"
# )
# 
# # Ensure it's treated as a widget
# class(overviewfig) <- c(class(overviewfig), "htmlwidget")
# 
# overviewfig


## ----scurve-projections-------------------------------------------------------

df_b_scurve <- df_bin_scurve |>
  dplyr::filter(h %in% df_bin_centroids_scurve$h) |>
  dplyr::mutate(type = "model") ## Data with summarized mean

## Reorder the rows of df_b according to the h order in df_b_with_center_data
df_b_scurve <- df_b_scurve[match(df_bin_centroids_scurve$h, df_b_scurve$h),] |>
  dplyr::select(-h) 

scurve_labeled <- scurve |>
  select(-ID) |>
  mutate(type = "data")

# Apply the scaling
df_model_data_scurve <- bind_rows(scurve_labeled, df_b_scurve)
scaled_scurve <- scale_data_manual(df_model_data_scurve, "type") |>
  as_tibble()

scaled_scurve_data <- scaled_scurve |>
  filter(type == "data") |>
  select(-type)

scaled_scurve_data_model <- scaled_scurve |>
  filter(type == "model") |>
  select(-type)


## First projection
projection <- cbind(
  c(0.10479,0.06673,0.19430,-0.14763,0.02861,-0.04302,0.06601),
  c(0.11421,0.18556,-0.16860,-0.05033,-0.00219,0.04159,0.04285))

proj_obj1 <- get_projection(projection = projection, 
                            proj_scale = 1.23, 
                            highd_data = scaled_scurve_data, 
                            model_highd = scaled_scurve_data_model, 
                            trimesh_data = tr_from_to_df_scurve, 
                            axis_param = list(limits = 0.5, 
                                              axis_scaled = 2,
                                              axis_pos_x = -0.25, 
                                              axis_pos_y = -0.25, 
                                              threshold = 0.0259))

scurve_proj_umap_model1 <- plot_proj(
  proj_obj = proj_obj1,
  point_param = c(0.5, 0.2, clr_choice), # size, alpha, color
  plot_limits = c(-0.35, 0.35), 
  axis_text_size = 2,
  is_category = FALSE) +
  interior_annotation(label = "a1", cex = 1)

scurve_proj_umap_model1_dp <- plot_proj(
  proj_obj = proj_obj1,
  point_param = c(0.2, 0, clr_choice), # size, alpha, color
  plot_limits = c(-0.35, 0.35), 
  axis_text_size = 3,
  is_category = FALSE) +
  interior_annotation(label = "d", cex = 1)

## Second projection

projection <- cbind(
  c(0.01588,-0.13640,-0.17180,-0.15486,-0.09726,0.00858,0.01090),
  c(0.21443,-0.00390,0.08182,-0.11746,0.06820,-0.05458,-0.08885))

proj_obj2 <- get_projection(projection = projection, 
                            proj_scale = 1.23, 
                            highd_data = scaled_scurve_data, 
                            model_highd = scaled_scurve_data_model, 
                            trimesh_data = tr_from_to_df_scurve, 
                            axis_param = list(limits = 0.5, 
                                              axis_scaled = 2,
                                              axis_pos_x = -0.25, 
                                              axis_pos_y = -0.25, 
                                              threshold = 0.0259))

scurve_proj_umap_model2 <- plot_proj(
  proj_obj = proj_obj2,
  point_param = c(0.5, 0.2, clr_choice), # size, alpha, color
  plot_limits = c(-0.35, 0.35), 
  axis_text_size = 2,
  is_category = FALSE) +
  interior_annotation(label = "a2", cex = 1) 

## Third projection

projection <- cbind(
  c(0.02727,0.09154,-0.16383,-0.04931,-0.17013,0.11965,-0.01884),
  c(-0.10510,-0.10971,-0.09084,0.19642,-0.07163,-0.02486,0.07965))

proj_obj3 <- get_projection(projection = projection, 
                            proj_scale = 1.23, 
                            highd_data = scaled_scurve_data, 
                            model_highd = scaled_scurve_data_model, 
                            trimesh_data = tr_from_to_df_scurve, 
                            axis_param = list(limits = 0.5, 
                                              axis_scaled = 2,
                                              axis_pos_x = -0.25, 
                                              axis_pos_y = -0.25, 
                                              threshold = 0.031))

scurve_proj_umap_model3 <- plot_proj(
  proj_obj = proj_obj3,
  point_param = c(0.5, 0.2, clr_choice), # size, alpha, color
  plot_limits = c(-0.35, 0.35), 
  axis_text_size = 2,
  is_category = FALSE) +
  interior_annotation(label = "a3", cex = 1) 

## Fourth projection

projection <- cbind(
  c(0.17174,0.14255,0.11950,0.10344,-0.07148,-0.01656,0.04275),
  c(0.09270,0.04486,-0.14397,0.08305,0.11783,0.16187,-0.06077))

proj_obj4 <- get_projection(projection = projection, 
                            proj_scale = 1.23, 
                            highd_data = scaled_scurve_data, 
                            model_highd = scaled_scurve_data_model, 
                            trimesh_data = tr_from_to_df_scurve, 
                            axis_param = list(limits = 0.5, 
                                              axis_scaled = 2,
                                              axis_pos_x = -0.25, 
                                              axis_pos_y = -0.25, 
                                              threshold = 0.031))

scurve_proj_umap_model4 <- plot_proj(
  proj_obj = proj_obj4,
  point_param = c(0.5, 0.2, clr_choice), # size, alpha, color
  plot_limits = c(-0.35, 0.35), 
  axis_text_size = 2,
  is_category = FALSE) +
  interior_annotation(label = "a4", cex = 1) 


## ----overview, eval=knitr::is_latex_output(), fig.cap="Wireframe model representation of the NLDR layout, lifted and displayed in high-dimensional space. The left panel shows the NLDR layout with a triangular mesh overlay, forming the wireframe structure. This mesh can be lifted into higher dimensions and projected to examine how the geometric structure of the data is preserved. Panels (a1–a4) display different $2\\text{-}D$ projections of the lifted wireframe, where the underlying curved sheet structure of the data is more clearly visible. The triangulated mesh highlights how local neighborhoods in the layout correspond to relationships in the high-dimensional space, enabling diagnostics of distortion and preservation across dimensions.", fig.pos="!ht", fig.alt="The UMAP layout with a triangular mesh on the left and the tour view of the lifted wireframe overlaying the data on the right. The mesh illustrates how local neighborhoods in the 2-D embedding correspond to curved sheet structures in the original high-dimensional S-curve data."----

hex_grid_scurve + wrap_plots(
  scurve_proj_umap_model1, scurve_proj_umap_model2,
  scurve_proj_umap_model3, scurve_proj_umap_model4, 
  ncol = 2)


## ----echo=TRUE, eval=TRUE-----------------------------------------------------
model_obj <- fit_highd_model(
  highd_data = scurve, 
  nldr_data = scurve_umap, 
  b1 = 21, 
  q = 0.1, 
  hd_thresh = 0)


## ----echo=TRUE, eval=TRUE-----------------------------------------------------
combined_data <- comb_data_model(
  highd_data = scurve,
  model_highd = model_obj$model_highd,
  model_2d = model_obj$model_2d
)

tour_view <- show_langevitour(
  point_data = combined_data,
  edge_data = model_obj$trimesh_data
)


## ----workflow, out.width = "100%", fig.pos="H", fig.cap="Overview of the `quollr` workflow and software architecture. The process begins with NLDR and $p\\text{-}D$ data inputs, followed by data preprocessing and hexagonal binning. Centroids are computed and triangulated to form the $2\\text{-}D$ mesh, which is then lifted into the $p\\text{-}D$ space. Predictions and error computations are performed on new data, while interactive functions enable dynamic linking between the $p\\text{-}D$ and $2\\text{-}D$ representations.", fig.alt = "Flowchart diagram illustrating the quollr workflow. It shows inputs of NLDR and high-dimensional data progressing through preprocessing, hexagonal binning, centroid computation, and triangulation to form a 2-D mesh. The mesh is lifted into the high-dimensional space for prediction and error analysis, with interactive tools linking the high- and low-dimensional representations."----

knitr::include_graphics("figures/quollr_workflow.png")


## ----algo-step-html, eval=knitr::is_html_output(), fig.pos="!ht", fig.cap="Key steps for constructing the model on the UMAP layout: (a) hexagon bins, (b) bin centroids, (c) triangulated centroids, and (d) lifting the model into high dimensions. The `scurve` data is shown.", layout = "l-body", fig.alt = "Four-panel figure showing the main steps in building the model on a UMAP layout using S-curve data: (a) hexagonal binning of points, (b) calculation of bin centroids, (c) triangulation of centroids to form a mesh, and (d) lifting the triangulated model into the high-dimensional space."----
# 
# algofig <- bscols(
#   htmltools::div(
#     style = "
#       display: flex;
#       justify-content: center;     /* centers the grid horizontally */
#       align-items: center;          /* optional: centers vertically if space allows */
#       margin: 0 auto;
#       padding: 0;
#     ",
#     htmltools::div(
#       style = "
#         display: grid;
#         grid-template-columns: 1fr 1fr;
#         gap: 0px;
#         align-items: start;
#         justify-items: center;
#         margin: 0;
#         padding: 0;
#       ",
#       htmltools::div(style = 'margin: 0; padding: 0;  height: 450px; width: 200px; text-align: left;', htmltools::h5("a"), hex_grid_poly_scurve_int),
#       htmltools::div(style = 'margin: 0; padding: 0; height: 450px; width: 200px; text-align: left;', htmltools::h5("b"), hex_centroids_scurve_int),
#       htmltools::div(style = 'margin: 0; padding: 0; height: 400px; width: 200px;  text-align: left;', htmltools::h5("c"), wireframe_scurve_int),
#       htmltools::div(style = 'margin: 0; padding: 0; height: 400px; width: 485px; text-align: left;', htmltools::div(
#     style = "margin-left: 140px;",
#     htmltools::h5("d"),
#     htmltools::div(style = "margin-left: 30px; margin-top: 47px; height: 360px; width: 360px;", scurve_umap_model_vis_n)
#   ))
#     )
#   ),
#   device = "xs"
# )
# 
# # Treat as HTML widget
# class(algofig) <- c(class(algofig), "htmlwidget")
# 
# algofig


## ----algo-steps, eval=knitr::is_latex_output(), out.width="80%", fig.height=5, fig.width=25, fig.pos="!ht", fig.align='center', fig.cap="Key steps for constructing the model on the UMAP layout: (a) hexagon bins, (b) bin centroids, (c) triangulated centroids, and (d) lifting the model into high dimensions. The \\texttt{scurve} data is shown.", fig.alt = "Four-panel figure showing the main steps in building the model on a UMAP layout using S-curve data: (a) hexagonal binning of points, (b) calculation of bin centroids, (c) triangulation of centroids to form a mesh, and (d) lifting the triangulated model into the high-dimensional space."----

hex_grid_poly_scurve +
  hex_centroids_scurve + wireframe_scurve + 
  scurve_proj_umap_model1_dp +
  plot_layout(ncol = 2)


## ----echo=TRUE----------------------------------------------------------------
scurve_umap_obj <- gen_scaled_data(nldr_data = scurve_umap)


## ----echo=TRUE----------------------------------------------------------------
bin_configs <- calc_bins_y(
  nldr_scaled_obj = scurve_umap_obj, 
  b1 = 21, 
  q = 0.1)

bin_configs


## ----echo=TRUE----------------------------------------------------------------
all_centroids_df <- gen_centroids(
  nldr_scaled_obj = scurve_umap_obj, 
  b1 = 21, 
  q = 0.1
)

head(all_centroids_df, 5)


## ----echo=TRUE----------------------------------------------------------------
all_hex_coord <- gen_hex_coord(
  centroids_data = all_centroids_df, 
  a1 = bin_configs$a1
)

head(all_hex_coord, 5)


## ----echo=TRUE----------------------------------------------------------------
umap_hex_id <- assign_data(
  nldr_scaled_obj = scurve_umap_obj, 
  centroids_data = all_centroids_df
)

head(umap_hex_id, 5)


## ----echo=TRUE----------------------------------------------------------------
pts_df <- group_hex_pts(
  scaled_nldr_hexid = umap_hex_id
)

head(pts_df, 5)


## ----echo=TRUE----------------------------------------------------------------
hb_obj <- hex_binning(
  nldr_scaled_obj = scurve_umap_obj, 
  b1 = 21, 
  q = 0.1)


## ----echo=TRUE----------------------------------------------------------------
std_df <- compute_std_counts(
  scaled_nldr_h = umap_hex_id
  )

head(std_df, 5)


## ----echo=TRUE----------------------------------------------------------------
df_bin_centroids <- merge_hexbin_centroids(
  centroids_data = all_centroids_df, 
  counts_data = hb_obj$std_cts
  )

head(df_bin_centroids, 5)


## ----echo=TRUE----------------------------------------------------------------
tr_object <- tri_bin_centroids(
  centroids_data = df_bin_centroids
  )


## ----echo=TRUE----------------------------------------------------------------
trimesh <- gen_edges(tri_object = tr_object, a1 = hb_obj$a1)

head(trimesh, 5)


## ----echo=TRUE----------------------------------------------------------------
trimesh <- update_trimesh_index(trimesh_data = trimesh)

head(trimesh, 5)


## ----echo=TRUE----------------------------------------------------------------
low_density_hex <- find_low_dens_hex(
  model_2d = df_bin_centroids, 
  b1 = 21, 
  md_thresh = 0.05
)


## ----echo=TRUE----------------------------------------------------------------
df_bin_centroids <- df_bin_centroids |>
  dplyr::filter(n_h > 0)

trimesh <- trimesh |>
  dplyr::filter(from_count > 0,
                to_count > 0)

trimesh <- update_trimesh_index(trimesh)


## ----echo=TRUE----------------------------------------------------------------
df_bin <- avg_highd_data(
  highd_data = scurve, 
  scaled_nldr_hexid = hb_obj$data_hb_id
)

head(df_bin, 5)


## ----echo=TRUE----------------------------------------------------------------
predict_data <- predict_emb(
  highd_data = scurve, 
  model_2d = df_bin_centroids, 
  model_highd = df_bin
  )

head(predict_data, 5)


## ----echo=TRUE----------------------------------------------------------------
glance(
  x = scurve_model_obj,
  highd_data = scurve
)


## ----echo=TRUE----------------------------------------------------------------
model_error <- augment(
  x = scurve_model_obj,
  highd_data = scurve
)


## ----echo=TRUE----------------------------------------------------------------
full_hexgrid <- ggplot() + 
  geom_hexgrid(
    data = hb_obj$centroids, 
    aes(x = c_x, y = c_y)
    ) 


## ----echo=TRUE----------------------------------------------------------------
data_hexgrid <- ggplot() + 
  geom_hexgrid(
    data = df_bin_centroids, 
    aes(x = c_x, y = c_y)
    ) 


## ----echo=TRUE----------------------------------------------------------------
full_triangulation_grid <- ggplot() + 
  geom_trimesh(
    data = hb_obj$centroids, 
    aes(x = c_x, y = c_y)
    ) 


## ----echo=TRUE----------------------------------------------------------------
data_triangulation_grid <- ggplot() + 
  geom_trimesh(
    data = df_bin_centroids, 
    aes(x = c_x, y = c_y)
    ) 


## -----------------------------------------------------------------------------

full_hexgrid <- full_hexgrid + 
  xlim(c(-0.2, 1.32)) +
  ylim(c(-0.2, 1.32)) + interior_annotation("a", cex = 3)

data_hexgrid <- data_hexgrid + 
  interior_annotation("b", cex = 3)

full_triangulation_grid <- full_triangulation_grid + 
  xlim(c(-0.2, 1.32)) +
  ylim(c(-0.2, 1.32)) + interior_annotation("c", cex = 3)

data_triangulation_grid <- data_triangulation_grid + 
  interior_annotation("d", cex = 3)



## ----geom-outputs, fig.cap="The outputs of `geom_hexgrid` and `geom_trimesh` include: (a) a complete hexagonal grid, (b) a hexagonal grid that corresponds with the data, (c) a full grid based on centroid triangulation, and (d) a centroid triangulation grid that aligns with the data.", fig.align='center', fig.pos="!ht", fig.height=5, fig.width=20, eval=knitr::is_html_output(), fig.alt = "Four-panel figure showing outputs from geom_hexgrid and geom_trimesh functions: (a) the full hexagonal grid, (b) the subset of the grid that overlaps with the data, (c) a complete triangulated grid based on centroids, and (d) the triangulated centroid grid corresponding to the data region."----
# 
# full_hexgrid + data_hexgrid +
#   full_triangulation_grid + data_triangulation_grid +
#   plot_layout(ncol = 4)


## ----geom-outputs-pdf, fig.cap="The outputs of \\texttt{geom\\_hexgrid} and \\texttt{geom\\_trimesh} include: (a) a complete hexagonal grid, (b) a hexagonal grid that corresponds with the data, (c) a full grid based on centroid triangulation, and (d) a centroid triangulation grid that aligns with the data.", fig.align='center', fig.pos="!ht", fig.height=5, fig.width=20, eval=knitr::is_latex_output(), fig.alt = "Four-panel figure showing outputs from geom_hexgrid and geom_trimesh functions: (a) the full hexagonal grid, (b) the subset of the grid that overlaps with the data, (c) a complete triangulated grid based on centroids, and (d) the triangulated centroid grid corresponding to the data region."----

 full_hexgrid + 
  data_hexgrid +  
  full_triangulation_grid + 
  data_triangulation_grid +
  plot_layout(ncol = 4)


## ----echo=TRUE----------------------------------------------------------------
df_exe <- comb_data_model(
  highd_data = scurve, 
  model_highd = df_bin, 
  model_2d = df_bin_centroids
  )


## ----scurve-highd-model-html, echo=TRUE, eval=knitr::is_html_output(), fig.pos="!ht", fig.width=20, fig.height=5, fig.cap="\\texttt{langevitour} output of the lifted high-dimensional wireframe model from the \\texttt{scurve} UMAP layout. These views illustrate how the lifted wireframe model captures the structure of the \\texttt{scurve} data. Regions with sparse or no data in the UMAP layout are also visible in the lifted model.", fig.alt = "Interactive langevitour visualization showing the lifted high-dimensional wireframe model derived from the S-curve UMAP layout. The views reveal how the wireframe follows the underlying S-curve structure and highlight regions with sparse or missing data in the original layout."----
# 
# show_langevitour(
#   point_data = df_exe,
#   edge_data = trimesh
#   )


## ----scurve-highd-model-pdf, eval=knitr::is_latex_output(), fig.pos="!ht", fig.cap="$2\\text{-}D$ projections of the lifted high-dimensional wireframe model from the \\texttt{scurve} UMAP layout. Each panel (a1–a4) shows the model (black) overlaid on \\texttt{scurve} data (blue) in different projections. These views illustrate how the lifted wireframe model captures the structure of the \\texttt{scurve} data. Regions with sparse or no data in the UMAP layout are also visible in the lifted model.", fig.alt = "Four-panel figure showing 2-D projections of the lifted high-dimensional wireframe model from the S-curve UMAP layout. Each panel displays the black wireframe model overlaid on blue S-curve data points, illustrating how the model captures the curved structure and revealing regions with sparse or no data."----

scurve_proj_umap_model1 + scurve_proj_umap_model2 + 
  scurve_proj_umap_model3 + scurve_proj_umap_model4 + 
  plot_layout(ncol = 4)


## ----scurve-highd-model-detourrpdf, out.width=c("50%", "50%"), fig.cap="Screenshots of the lifted high-dimensional wireframe model from the \\texttt{scurve} UMAP layout using \\texttt{detourr}. Regions with sparse or no data in the UMAP layout are also visible in the lifted model.", fig.alt = "Screenshots from the detourr interface showing the lifted high-dimensional wireframe model derived from the S-curve UMAP layout. The images highlight how the wireframe represents the data structure and expose regions with sparse or missing data.", fig.pos="H", fig.show='hold', eval=knitr::is_latex_output()----

knitr::include_graphics(c("figures/model_proj1_detourr.png",
                          "figures/model_proj2_detourr.png"))


## ----scurve-highd-model-detourrhtml, echo=TRUE, eval=knitr::is_html_output(), fig.cap="`detourr` output of the lifted high-dimensional wireframe model from the `scurve` UMAP layout. These views illustrate how the lifted wireframe model captures the structure of the Scurve data. Regions with sparse or no data in the UMAP layout are also visible in the lifted model.", fig.alt = "Multiple views from the detourr output showing the lifted high-dimensional wireframe model based on the S-curve UMAP layout. The wireframe reflects the curved structure of the S-curve data and reveals areas with sparse or no data in the original layout."----
# 
# detour(
#   df_exe,
#   tour_aes(
#     projection = starts_with("x"),
#     colour = type
#   )
# ) |>
#   tour_path(grand_tour(2),
#                     max_bases=50, fps = 60) |>
#   show_scatter(axes = TRUE, size = 1.5, alpha = 0.5,
#                edges = as.matrix(trimesh[, c("from_reindexed", "to_reindexed")]),
#                palette = c("#66B2CC", "#FF7755"),
#                width = "600px", height = "600px")


## ----echo=TRUE----------------------------------------------------------------
df_exe <- comb_all_data_model(
  highd_data = scurve, 
  nldr_data = scurve_umap, 
  model_highd = df_bin, 
  model_2d = df_bin_centroids
  )


## ----scurve-nldrlink-html, echo=TRUE, eval=knitr::is_html_output(), fig.cap="Interactively linked plots connecting the UMAP layout (left) and the fitted model overlaid with the data in $7\\text{-}D$ (right) using `langevitour`. Brushing in either view highlights the corresponding subset of points across both representations, allowing examination of how well the UMAP layout preserves the underlying `scurve` structure. Double-clicking on either view clears the selection and dehighlights all points.", fig.alt = "Interactive two-panel linked plots showing the connection between the UMAP layout on the left and the fitted model with S-curve data in seven dimensions on the right, displayed using langevitour. Brushing highlights matching points across both views, enabling comparison of structure preservation between the 2-D layout and the high-dimensional data.", layout = "l-body"----
# 
# nldrdt_link <- show_link_plots(
#   point_data = df_exe,
#   edge_data = trimesh,
#   point_colour = clr_choice
#   )
# 
# nldrdt_link <- crosstalk::bscols(
#     htmltools::div(
#         style = "display: grid; grid-template-columns: 1fr 1fr;
#     gap: 0px; align-items: start; justify-items: center; margin: 0; padding: 0;
#     height: 380px; width: 500px",
#         nldrdt_link
#     ),
#     device = "xs"
# )
# 
# class(nldrdt_link) <- c(class(nldrdt_link), "htmlwidget")
# 
# nldrdt_link


## -----------------------------------------------------------------------------
## Create the first row of selection
scurve_umap_scaled_select1 <- scurve_umap_scaled |>
  mutate(select_area = if_else(emb1 <= 0.7 & emb1 >= 0.4 & emb2 <= 0.25 & emb2 >= 0, "selected", "deselected"))

scurve_umap_scaled_select1_selected <- scurve_umap_scaled_select1 |>
  filter(select_area == "selected")

scurve_umap_scaled_select1_deselected <- scurve_umap_scaled_select1 |>
  filter(select_area == "deselected")

scurve_umap_plt_select1 <- ggplot(
  scurve_umap_scaled_select1_deselected, 
  aes(x = emb1, y = emb2)) +
  geom_point(alpha = 0.5, color = clr_choice, size = 0.5) +
  geom_point(data = scurve_umap_scaled_select1_selected, aes(x = emb1, y = emb2), alpha = 0.5, color = "#756bb1", size = 0.5) +
  xlim(sc_xlims) +
  ylim(sc_ylims)

scurve_umap_plt_select1_lk <- scurve_umap_plt_select1 +
  interior_annotation("a1", cex = 3)

scurve_umap_plt_select1_lk2 <- scurve_umap_plt_select1 +
  interior_annotation("a2", cex = 3) 

proj_obj2[["cluster"]] <- factor(scurve_umap_scaled_select1$select_area,
                                 levels=c("deselected", "selected"))

projected_df <- proj_obj2$projected_df
model_df <- proj_obj2$model_df
axes <- proj_obj2$axes
circle <- proj_obj2$circle

projected_df <- projected_df |>
  dplyr::mutate(cluster = proj_obj2$cluster)

scurve_proj_umap_model1_selected1 <- ggplot() +
      geom_point(
        data = projected_df,
        aes(
          x = proj1,
          y = proj2,
          colour = factor(cluster, levels = c("deselected", "selected")),
          size = factor(cluster, levels = c("deselected", "selected"))),
        alpha = 0.5) +
      geom_segment(
        data = model_df,
        aes(
          x = proj1_from,
          y = proj2_from,
          xend = proj1_to,
          yend = proj2_to),
        colour = "#000000",
        linewidth = 0.8,
        alpha = 0.4) +
      geom_segment(
          data=axes,
          aes(x=x1, y=y1, xend=x2, yend=y2),
          colour="grey70") +
        geom_text(
          data=axes,
          aes(x=x2, y=y2),
          label=rownames(axes),
          colour="grey50",
          size = 5) +
        geom_path(
          data=circle,
          aes(x=c1, y=c2), colour="grey70") +
        xlim(c(-0.35, 0.35)) +
        ylim(c(-0.35, 0.35)) +
  interior_annotation(label = "a2", cex = 3) +
  scale_color_manual(values = c(clr_choice, '#756bb1')) +
  scale_size_manual(values = c('deselected' = 1.0, 'selected' = 1.5)) +
  theme(aspect.ratio = 1,
        legend.position = "none")

scurve_proj_umap_model1_selected1_dp <- ggplot() +
      geom_point(
        data = projected_df,
        aes(
          x = proj1,
          y = proj2,
          colour = factor(cluster, levels = c("deselected", "selected")),
          size = factor(cluster, levels = c("deselected", "selected"))),
        alpha = 0.5) +
      geom_segment(
        data = model_df,
        aes(
          x = proj1_from,
          y = proj2_from,
          xend = proj1_to,
          yend = proj2_to),
        colour = "#000000",
        linewidth = 0.8,
        alpha = 0.4) +
      geom_segment(
          data=axes,
          aes(x=x1, y=y1, xend=x2, yend=y2),
          colour="grey70") +
        geom_text(
          data=axes,
          aes(x=x2, y=y2),
          label=rownames(axes),
          colour="grey50",
          size = 5) +
        geom_path(
          data=circle,
          aes(x=c1, y=c2), colour="grey70") +
        xlim(c(-0.35, 0.35)) +
        ylim(c(-0.35, 0.35)) +
  interior_annotation(label = "a3", cex = 3) +
  scale_color_manual(values = c(clr_choice, '#756bb1')) +
  scale_size_manual(values = c('deselected' = 1.0, 'selected' = 1.5)) +
  theme(aspect.ratio = 1,
        legend.position = "none")

## Create the second row of selection
scurve_umap_scaled_select2 <- scurve_umap_scaled |>
  mutate(select_area = if_else(emb1 <= 0.55 & emb1 >= 0.25 & emb2 <= 1.25 & emb2 >= 0.75, "selected", "deselected"))

scurve_umap_scaled_select2_selected <- scurve_umap_scaled_select2 |>
  filter(select_area == "selected")

scurve_umap_scaled_select2_deselected <- scurve_umap_scaled_select2 |>
  filter(select_area == "deselected")

scurve_umap_plt_select2 <- ggplot(
  scurve_umap_scaled_select2_deselected, 
  aes(x = emb1, y = emb2)) +
  geom_point(alpha = 0.5, color = clr_choice, size = 0.5) +
  geom_point(data = scurve_umap_scaled_select2_selected, aes(x = emb1, y = emb2), alpha = 0.5, color = "#756bb1", size = 0.5) +
  xlim(sc_xlims) +
  ylim(sc_ylims)

scurve_umap_plt_select2_lk <- scurve_umap_plt_select2 +
    interior_annotation("b1", cex = 3) 

scurve_umap_plt_select2_lk2 <- scurve_umap_plt_select2 +
    interior_annotation("b2", cex = 3) 

proj_obj2[["cluster"]] <- factor(scurve_umap_scaled_select2$select_area,
                                 levels=c("deselected", "selected"))

projected_df <- proj_obj2$projected_df
model_df <- proj_obj2$model_df
axes <- proj_obj2$axes
circle <- proj_obj2$circle

projected_df <- projected_df |>
  dplyr::mutate(cluster = proj_obj2$cluster)

scurve_proj_umap_model1_selected2 <- ggplot() +
      geom_point(
        data = projected_df,
        aes(
          x = proj1,
          y = proj2,
          colour = factor(cluster, levels = c("deselected", "selected")),
          size = factor(cluster, levels = c("deselected", "selected"))),
        alpha = 0.5) +
      geom_segment(
        data = model_df,
        aes(
          x = proj1_from,
          y = proj2_from,
          xend = proj1_to,
          yend = proj2_to),
        colour = "#000000",
        linewidth = 0.8,
        alpha = 0.4) +
      geom_segment(
          data=axes,
          aes(x=x1, y=y1, xend=x2, yend=y2),
          colour="grey70") +
        geom_text(
          data=axes,
          aes(x=x2, y=y2),
          label=rownames(axes),
          colour="grey50",
          size = 5) +
        geom_path(
          data=circle,
          aes(x=c1, y=c2), colour="grey70") +
        xlim(c(-0.35, 0.35)) +
        ylim(c(-0.35, 0.35)) +
  interior_annotation(label = "b2", cex = 3) +
  scale_color_manual(values = c(clr_choice, '#756bb1')) +
  scale_size_manual(values = c('deselected' = 1.0, 'selected' = 1.5)) +
  theme(aspect.ratio = 1,
        legend.position = "none")

scurve_proj_umap_model1_selected2_dp <- ggplot() +
      geom_point(
        data = projected_df,
        aes(
          x = proj1,
          y = proj2,
          colour = factor(cluster, levels = c("deselected", "selected")),
          size = factor(cluster, levels = c("deselected", "selected"))),
        alpha = 0.5) +
      geom_segment(
        data = model_df,
        aes(
          x = proj1_from,
          y = proj2_from,
          xend = proj1_to,
          yend = proj2_to),
        colour = "#000000",
        linewidth = 0.8,
        alpha = 0.4) +
      geom_segment(
          data=axes,
          aes(x=x1, y=y1, xend=x2, yend=y2),
          colour="grey70") +
        geom_text(
          data=axes,
          aes(x=x2, y=y2),
          label=rownames(axes),
          colour="grey50",
          size = 5) +
        geom_path(
          data=circle,
          aes(x=c1, y=c2), colour="grey70") +
        xlim(c(-0.35, 0.35)) +
        ylim(c(-0.35, 0.35)) +
  interior_annotation(label = "b3", cex = 3) +
  scale_color_manual(values = c(clr_choice, '#756bb1')) +
  scale_size_manual(values = c('deselected' = 1.0, 'selected' = 1.5)) +
  theme(aspect.ratio = 1,
        legend.position = "none")


## ----scurve-nldrlink-pdf, eval=knitr::is_latex_output(), fig.pos="!ht", fig.width=10, fig.height=10, fig.cap="Exploring the correspondence between UMAP layout and \\texttt{scurve} structure in $7\\text{-}D$. Two sets of plots are interactively linked: UMAP layout (a1, b1) and projection of $7\\text{-}D$ model and data (a2, b2). The purple points indicate the selected subsets, which differ between rows. In (a1), the lower bridge of the \\texttt{scurve} is highlighted, which corresponds in (a2) to points spanning across both arms of the high-dimensional structure. In (b1), a different region near the upper arm of the \\texttt{scurve} is selected, and in (b2) these points map onto one side of the curved manifold in $7\\text{-}D$ projection. While the UMAP layout suggests distinct local clusters, the linked tour views reveal how these selections trace continuous structures in the $7\\text{-}D$ space, highlighting distortions introduced by UMAP.", fig.alt = "Four-panel figure with linked views showing correspondence between the UMAP layout and the S-curve structure in seven dimensions. Panels (a1, b1) show selected regions in the UMAP layout, and panels (a2, b2) display the corresponding points in the high-dimensional tour view. Purple points indicate selected subsets: the lower bridge of the S-curve in (a1, a2) and the upper arm region in (b1, b2). The figure illustrates how continuous structures in the 7-D S-curve appear as separate clusters in the 2-D UMAP layout, revealing distortion effects."----

scurve_umap_plt_select1_lk + scurve_proj_umap_model1_selected1 +
  scurve_umap_plt_select2_lk + scurve_proj_umap_model1_selected2 +
  plot_layout(ncol = 2)


## ----echo=TRUE----------------------------------------------------------------
df_exe <- comb_all_data_model_error(
  highd_data = scurve, 
  nldr_data = scurve_umap, 
  model_highd = df_bin, 
  model_2d = df_bin_centroids, 
  error_data = model_error
  )


## ----scurve-linkerror-html, echo=TRUE, eval=knitr::is_html_output(), fig.cap="Interactively linked plots connecting the residual distribution (left), the UMAP layout (middle) and the fitted model overlaid with the data in $7\\text{-}D$ (right) using `langevitour`. Brushing in any view highlights the corresponding subset across all panels, allowing detailed inspection of how residuals relate to both the UMAP embedding and the $p\\text{-}D$ structure. Points with higher residuals typically correspond to sparse or bridging regions in the UMAP layout and the less dense ends of the Scurve, whereas low-residual points tend to cluster within denser, well-preserved regions. Double-clicking clears the selection and resets all highlights.", fig.alt = "Interactive three-panel linked plots showing the residual distribution (left), UMAP layout (middle), and fitted model overlaid with S-curve data in seven dimensions (right) using langevitour. Brushing highlights corresponding points across all panels, illustrating how high-residual points align with sparse or bridging regions in the UMAP and less dense ends of the S-curve, while low-residual points cluster in denser regions.", layout = "l-body"----
# 
# errornldrdt_link <- show_error_link_plots(
#   point_data = df_exe,
#   edge_data = trimesh,
#   point_colour = clr_choice
# )
# 
# class(errornldrdt_link) <- c(class(errornldrdt_link), "htmlwidget")
# 
# errornldrdt_link


## -----------------------------------------------------------------------------
model_error <- model_error |>
  bind_cols(scurve_umap_scaled |>
              select(-ID))

model_error <- model_error |>
  mutate(sqrt_row_wise_total_error = sqrt(row_wise_total_error))

# Compute density
density_data <- density(model_error$sqrt_row_wise_total_error)
density_df <- data.frame(x = density_data$x, y = density_data$y)

# Add density values to the original dataset
model_error <- model_error |>
  mutate(density = approx(density_df$x, density_df$y, xout = sqrt_row_wise_total_error)$y)

## Create the first row of selection
model_error_select1 <- model_error |>
  mutate(select_area = if_else(emb1 <= 0.7 & emb1 >= 0.4 & emb2 <= 0.25 & emb2 >= 0, "selected", "deselected"))

model_error_select1_selected <- model_error_select1 |>
  filter(select_area == "selected")

model_error_select1_deselected <- model_error_select1 |>
  filter(select_area == "deselected")

error_plot_scurve_hist1 <- ggplot(model_error_select1_deselected, 
      aes(x = sqrt_row_wise_total_error, 
          y = density)) +
  geom_point(alpha=0.7, colour = "#d9d9d9") +
  geom_point(data = model_error_select1_selected, 
      aes(x = sqrt_row_wise_total_error, 
          y = density),
      alpha=0.7, colour = "#756bb1", size = 3) +
  xlab(paste("residual")) +
  ylab("") +
  interior_annotation("a1", cex = 3) +
  theme_bw() +
  theme(axis.ticks.y = element_blank(),
        axis.title.x = element_text(size = 18),
        axis.text.x = element_text(size = 15),
        axis.text.y = element_blank(),
        aspect.ratio = 1)

## Create the second row of selection
model_error_select2 <- model_error |>
  mutate(select_area = if_else(emb1 <= 0.55 & emb1 >= 0.25 & emb2 <= 1.25 & emb2 >= 0.75, "selected", "deselected"))

model_error_select2_selected <- model_error_select2 |>
  filter(select_area == "selected")

model_error_select2_deselected <- model_error_select2 |>
  filter(select_area == "deselected")

error_plot_scurve_hist2 <- ggplot(model_error_select2_deselected, 
      aes(x = sqrt_row_wise_total_error, 
          y = density)) +
  geom_point(alpha=0.7, colour = "#d9d9d9") +
  geom_point(data = model_error_select2_selected, 
      aes(x = sqrt_row_wise_total_error, 
          y = density),
      alpha=0.7, colour = "#756bb1", size = 3) +
  xlab(paste("residual")) +
  ylab("") +
  interior_annotation("b1", cex = 3) +
  theme_bw() +
  theme(axis.ticks.y = element_blank(),
        axis.title.x = element_text(size = 18),
        axis.text.x = element_text(size = 15),
        axis.text.y = element_blank(),
        aspect.ratio = 1)


## ----scurve-linkerror-pdf, eval=knitr::is_latex_output(), fig.pos="H", fig.width=15, fig.height=10, fig.cap="Exploring residuals in relation to UMAP layouts using a $7\\text{-}D$ \\texttt{scurve} model. Three views are linked: distribution of residuals (a1, b1), UMAP layout (a2, b2), and projection of the $7\\text{-}D$ model with data (a3, b3). The purple points highlight selected subsets of the data, which differ across rows. In the top row (a1–a3), points with higher residuals (a1) are selected, corresponding to the sparse bridging region in the UMAP layout (a2) and the less dense end of the \\texttt{scurve} in the high-dimensional projection (a3). In the bottom row (b1–b3), points with lower residuals (b1) are highlighted, which map to one side of the dense region in the NLDR layout (b2) and to a thicker band of the \\texttt{scurve} in the projection (b3). This comparison illustrates how residuals can help diagnose distortions in UMAP, with high-residual points often concentrated in sparse or stretched regions of the structure.", fig.alt = "Six-panel figure showing linked views of residuals and UMAP layouts for the 7-D S-curve model. Panels (a1–a3) highlight high-residual points in purple, corresponding to sparse bridging regions in the UMAP layout and less dense ends of the high-dimensional S-curve. Panels (b1–b3) highlight low-residual points, mapping to denser regions in the UMAP and thicker bands in the high-dimensional projection. The figure illustrates how residuals reveal distortions in UMAP embeddings."----

error_plot_scurve_hist1 + scurve_umap_plt_select1_lk2 + scurve_proj_umap_model1_selected1_dp +
  error_plot_scurve_hist2 + scurve_umap_plt_select2_lk2 + scurve_proj_umap_model1_selected2_dp +
  plot_layout(ncol = 3)


## -----------------------------------------------------------------------------
#| label: read-limb-nldr
# Read a variety of different NLDR representations of limb
# and plot them on same aspect ratio

tsne_limb <- read_rds("data/limb_muscles/facs_limb_muscles_tsne_perplexity_30.rds")

nldr1 <- tsne_limb |>
  ggplot(aes(x = emb1,
             y = emb2)) +
  geom_point(alpha=0.1, size=1, colour='#a65628') +
  interior_annotation("a")

umap_limb <- read_rds("data/limb_muscles/facs_limb_muscles_umap_n-neigbors_15_min-dist_0.1.rds")

nldr2 <- umap_limb |>
  ggplot(aes(x = emb1,
             y = emb2)) +
  geom_point(alpha=0.1, size=1, colour='#999999') +
  interior_annotation("b")

phate_limb <- read_rds("data/limb_muscles/facs_limb_muscles_phate_knn_5.rds")

nldr3 <- phate_limb |>
  ggplot(aes(x = emb1,
             y = emb2)) +
  geom_point(alpha=0.1, size=1, colour='#e41a1c') +
  interior_annotation("c")

trimap_limb <- read_rds("data/limb_muscles/facs_limb_muscles_trimap_n-inliers_12_n-outliers_4_n-random_3.rds")

nldr4 <- trimap_limb |>
  ggplot(aes(x = emb1,
             y = emb2)) +
  geom_point(alpha=0.1, size=1, colour='#984ea3') +
  interior_annotation("d")

pacmap_limb <- read_rds("data/limb_muscles/facs_limb_muscles_pacmap_n-neighbors_10_init_random_MN-ratio_0.5_FP-ratio_2.rds")

nldr5 <- pacmap_limb |>
  ggplot(aes(x = emb1,
             y = emb2)) +
  geom_point(alpha=0.1, size=1, colour='#4daf4a') +
  interior_annotation("e")

tsne_limb2 <- read_rds("data/limb_muscles/facs_limb_muscles_tsne_perplexity_15.rds")

nldr6 <- tsne_limb2 |>
  ggplot(aes(x = emb1,
             y = emb2)) +
  geom_point(alpha=0.1, size=1, colour='#ff7f00') +
  interior_annotation("f")


## -----------------------------------------------------------------------------
#| label: combine-error-data-muscles

error_limb_umap <- read_rds("data/limb_muscles/error_limb_muscles_umap_n-neigbors_15_min-dist_0.1.rds")
error_limb_tsne <- read_rds("data/limb_muscles/error_limb_muscles_tsne_perplexity_30.rds")
error_limb_phate <- read_rds("data/limb_muscles/error_limb_muscles_phate_knn_5.rds")
error_limb_trimap <- read_rds("data/limb_muscles/error_limb_muscles_trimap_n-inliers_12_n-outliers_4_n-random_3.rds")
error_limb_pacmap <- read_rds("data/limb_muscles/error_limb_muscles_pacmap_n-neighbors_10_init_random_MN-ratio_0.5_FP-ratio_2.rds")

error_limb_tsne2 <- read_rds("data/limb_muscles/error_limb_muscles_tsne_perplexity_15.rds")

error_limb <- bind_rows(error_limb_umap, 
                        error_limb_tsne,
                        error_limb_phate,
                        error_limb_trimap,
                        error_limb_pacmap,
                        error_limb_tsne2)

error_limb <- error_limb |>
  mutate(a1 = round(a1, 2)) |>
  filter(b1 >= 5) |>
  filter(a1 >= 0.03) |>
  group_by(method, a1) |>
  filter(HBE == min(HBE)) |>
  ungroup()

error_limb <- error_limb |>
  mutate(method = factor(method,
                         levels = c("tsne_30", "UMAP_15_min_dist_0.1", "phate_5", "trimap_n-inliers_12_n-outliers_4_n-random_3", "pacmap_n-neighbors_10_init_random_MN-ratio_0.5_FP-ratio_2", "tsne_15")))


## -----------------------------------------------------------------------------
#| label: error-comp-muscles

error_plot_limb <- plot_hbe(error_limb) +
  scale_x_continuous(breaks = sort(unique(error_limb$a1))[c(1, 5, 9, 13, 17, 21, 26)]) +
  scale_color_manual(values=c('#a65628','#999999','#e41a1c','#984ea3','#4daf4a','#ff7f00')) 



## ----limb-hbe, fig.cap="Assessing which of the 6 NLDR layouts on the limb muscle data is the better representation using HBE for varying binwidth ($a_1$). Colour  used for the lines and points in the left plot and in the scatterplots represents NLDR layout (a-f). Layout d performs well at large binwidth (where the binwidth is not enough to capture the data structure) and poorly as the bin width decreases. Layout f is the best choice.\\label{fig:limb-hbe}", fig.alt = "Evaluation of six NLDR layouts (a–f) on limb muscle data using HBE across different binwidths (a1). Line and point colors correspond to layouts. Layout d performs well at large binwidths but poorly as binwidth decreases, while layout f consistently provides the best representation.", fig.pos="!ht", echo=TRUE----

design <- gen_design(n_right = 6, ncol_right = 2)

plot_hbe_layouts(plots = list(error_plot_limb, nldr1, 
                             nldr2, nldr3, nldr4, 
                             nldr5, nldr6), design = design)


## ----data-limb----------------------------------------------------------------
data_limb <- read_rds("data/limb_muscles/facs_limb_muscles_pcs_10.rds")

cluster_df <- read_rds("data/limb_muscles/facs_limb_muscles_cluster_df.rds")


## -----------------------------------------------------------------------------
#| label: tsne-model-limb

tsne_limb_obj <- fit_highd_model(
  highd_data = data_limb, 
  nldr_data = tsne_limb, 
  b1 = 28, 
  q = 0.1, 
  hd_thresh = 0)

df_bin_centroids_limb <- tsne_limb_obj$model_2d
df_bin_limb <- tsne_limb_obj$model_highd
trimesh_data_limb <- tsne_limb_obj$trimesh_data
tsne_limb_scaled <- tsne_limb_obj$nldr_scaled_obj$scaled_nldr

tsne_limb_scaled_with_cluster <- inner_join(tsne_limb_scaled, cluster_df, by = "ID") |>
  mutate(cluster = as.character(cluster.ids))

trimesh_limb <- ggplot() + 
  geom_point(
    data = tsne_limb_scaled_with_cluster,
    aes(
      x = emb1,
      y = emb2,
      color = cluster
    ),
    alpha = 0.3
  ) +
  geom_segment(data = trimesh_data_limb, 
               aes(
                 x = x_from, 
                 y = y_from, 
                 xend = x_to, 
                 yend = y_to),
               colour = "#000000",
               linewidth = 1) +
  scale_color_manual(values = c('#66c2a5','#fc8d62','#8da0cb','#e78ac3','#a6d854','#ffd92f','#e5c494')) +
  interior_annotation("a1", cex = 2) +
  theme(
    aspect.ratio = 1
  )


## -----------------------------------------------------------------------------
#| label: prep-limb-tsne-author-model-proj

data_limb_n <- data_limb |> 
  select(-ID) |>
  mutate(type = "data")

df_b_limb <- df_bin_limb |>
  dplyr::filter(h %in% df_bin_centroids_limb$h) |>
  dplyr::mutate(type = "model") ## Data with summarized mean

## Reorder the rows of df_b according to the h order in df_b_with_center_data
df_b_limb <- df_b_limb[match(df_bin_centroids_limb$h, df_b_limb$h),] |>
  dplyr::select(-h) 

# Apply the scaling
df_model_data_limb <- bind_rows(data_limb_n, df_b_limb)
scaled_limb <- scale_data_manual(df_model_data_limb, "type") |>
  as_tibble()

scaled_limb_data <- scaled_limb |>
  filter(type == "data") |>
  select(-type)

scaled_limb_data_model <- scaled_limb |>
  filter(type == "model") |>
  select(-type)


## -----------------------------------------------------------------------------

df <- inner_join(data_limb, tsne_limb_scaled_with_cluster, by = "ID")

### Define type column
df <- df |>
  select(starts_with("x"), starts_with("emb"), "cluster") |>
  mutate(type = tsne_limb_scaled_with_cluster$cluster) ## original dataset

df_b <- df_bin_limb |>
  filter(h %in% df_bin_centroids_limb$h) |>
  mutate(type = "model") ## Data with summarized mean

## Reorder the rows of df_b according to the h order in model_2d
df_b <- df_b[match(df_bin_centroids_limb$h, df_b$h),] |>
  tidyr::drop_na() |>
  select(-h)

df_exe_limb_int <- bind_rows(df_b, df)

point_data <- df_exe_limb_int 
edge_data <- trimesh_data_limb

num_highd_col <- point_data |>
  dplyr::select(starts_with("x")) |>
  NCOL()

shared_df <- crosstalk::SharedData$new(point_data)

cluster_colors <- c(
    "0" = '#66c2a5', "1" = '#fc8d62', "2" = '#8da0cb',
    "3" = '#e78ac3', "4" = '#a6d854', "5" = '#ffd92f', "6" = '#e5c494'
)

point_sizes <- c(0, 1)

# Scatter points
nldr_plt <- plot_ly(
    data = shared_df,
    x = ~emb1, y = ~emb2,
    type = "scatter", mode = "markers",
    color = ~cluster, colors = cluster_colors,
    marker = list(size = 3, opacity = 0.5),
    hoverinfo = "skip",  # <-- skip hover completely
    showlegend = FALSE
)

# Add line segments
if (nrow(trimesh_data_limb) > 0) {
    nldr_plt <- nldr_plt |>
        add_segments(
            data = trimesh_data_limb,
            x = ~x_from, y = ~y_from,
            xend = ~x_to, yend = ~y_to,
            line = list(color = "#000000", width = 0.5),
            inherit = FALSE,
            showlegend = FALSE,
            hoverinfo = "skip"  # <-- skip hover
        )
}

# Layout: axes, border, no tooltip
nldr_plt <- nldr_plt |>
    layout(
        width = 310, height = 310,
        margin = list(l = 20, r = 20, t = 20, b = 20),
        xaxis = list(title = "", showgrid = FALSE, zeroline = FALSE,
                     showticklabels = FALSE, ticks = "", linecolor = "black", mirror = TRUE),
        yaxis = list(title = "", showgrid = FALSE, zeroline = FALSE,
                     showticklabels = FALSE, ticks = "", linecolor = "black", mirror = TRUE)
    ) |>
    style(
        selected = list(marker = list(opacity = 1)),
        unselected = list(marker = list(opacity = 1))
    ) |>
    highlight(
        on = "plotly_selected",
        off = "plotly_deselect"
    ) |>
    config(displayModeBar = FALSE)


langevitour_output <- langevitour::langevitour(point_data[1:num_highd_col],
                                               lineFrom = edge_data$from_reindexed,
                                               lineTo = edge_data$to_reindexed,
                                               group = factor(point_data$type,
                                                              c("0", "1", "2", "3", "4", "5", "6", "model")),
                                               pointSize = append(rep(point_sizes[1], NROW(df_b)),
                                                                  rep(point_sizes[2], NROW(df))),
                                               levelColors = c('#66c2a5','#fc8d62','#8da0cb','#e78ac3','#a6d854','#ffd92f','#e5c494', "#000000"),
                                               link=shared_df,
                                               linkFilter=FALSE,
                                               width = "370px", height = "370px")

linked_plt_int <- crosstalk::bscols(
    htmltools::div(
        style = "display: grid; grid-template-columns: 1fr 1fr;
    gap: 0px;
    align-items: start;
    justify-items: center;
    margin: 0;
    padding: 0;
    height: 380px;
    width: 500px",
        nldr_plt, 
        htmltools::div(style = "margin-top: 20px;", langevitour_output)
    ),
    device = "xs"
)



## ----plot-proj----------------------------------------------------------------

## First projection
projection <- cbind(
  c(-0.021068,0.007018,0.008770,0.016884,-0.008135,0.011458,-0.022323,0.007231,0.004976,-0.019298),
  c(-0.017371,-0.008514,0.003231,-0.022945,-0.026264,-0.001571,0.008007,-0.001268,-0.016923,-0.006700))

proj_obj1 <- get_projection(projection = projection, 
                            proj_scale = 1.23, 
                            highd_data = scaled_limb_data, 
                            model_highd = scaled_limb_data_model, 
                            trimesh_data = trimesh_data_limb, 
                            axis_param = list(limits = 0.05,
                                              axis_scaled = 20, 
                                              axis_pos_x = -0.04, 
                                              axis_pos_y = -0.04, 
                                              threshold = 0.004))

proj_obj1[["cluster"]] <- as.character(tsne_limb_scaled_with_cluster$cluster)

limb_proj_tsne_model1 <- plot_proj(
  proj_obj = proj_obj1, 
  point_param = c(1.5, 0.2), # size, alpha, color
  plot_limits = c(-0.05, 0.03), 
  axis_text_size = 4,
  is_category = TRUE) +
  interior_annotation(label = "a2", cex = 2) + 
  scale_color_manual(values = c('#66c2a5','#fc8d62','#8da0cb','#e78ac3','#a6d854','#ffd92f','#e5c494'))

## Second projection
projection <- cbind(
  c(-0.025678,-0.017472,0.015634,-0.014868,-0.000752,0.001050,-0.019524,-0.008076,-0.010808,-0.002319),
  c(0.014526,-0.013526,-0.005147,-0.027612,-0.016919,0.005198,0.010710,0.004623,-0.007055,0.017842))

proj_obj2 <- get_projection(projection = projection, 
                            proj_scale = 1.23, 
                            highd_data = scaled_limb_data, 
                            model_highd = scaled_limb_data_model, 
                            trimesh_data = trimesh_data_limb, 
                            axis_param = list(limits = 0.05,
                                              axis_scaled = 20, 
                                              axis_pos_x = -0.03, 
                                              axis_pos_y = -0.03, 
                                              threshold = 0.004))

proj_obj2[["cluster"]] <- as.character(tsne_limb_scaled_with_cluster$cluster)

limb_proj_tsne_model2 <- plot_proj(
  proj_obj = proj_obj2, 
  point_param = c(1.5, 0.2), # size, alpha, color
  plot_limits = c(-0.04, 0.04), 
  axis_text_size = 4,
  is_category = TRUE) +
  interior_annotation(label = "a3", cex = 2) + 
  scale_color_manual(values = c('#66c2a5','#fc8d62','#8da0cb','#e78ac3','#a6d854','#ffd92f','#e5c494'))




## -----------------------------------------------------------------------------
#| label: tsne-best-model-limb

tsne_best_limb_obj <- fit_highd_model(
  highd_data = data_limb, 
  nldr_data = tsne_limb2, 
  b1 = 28, 
  q = 0.1, 
  hd_thresh = 0)

df_bin_centroids_limb <- tsne_best_limb_obj$model_2d
df_bin_limb <- tsne_best_limb_obj$model_highd
trimesh_data_limb <- tsne_best_limb_obj$trimesh_data
tsne_limb_scaled <- tsne_best_limb_obj$nldr_scaled_obj$scaled_nldr

tsne_limb_scaled_with_cluster <- inner_join(tsne_limb_scaled, cluster_df, by = "ID") |>
  mutate(cluster = as.character(cluster.ids))

trimesh_limb_best <- ggplot() + 
  geom_point(
    data = tsne_limb_scaled_with_cluster,
    aes(
      x = emb1,
      y = emb2,
      color = cluster
    ),
    alpha = 0.3
  ) +
  geom_segment(data = trimesh_data_limb, 
               aes(
                 x = x_from, 
                 y = y_from, 
                 xend = x_to, 
                 yend = y_to),
               colour = "#000000",
               linewidth = 1) +
  scale_color_manual(values = c('#66c2a5','#fc8d62','#8da0cb','#e78ac3','#a6d854','#ffd92f','#e5c494')) +
  interior_annotation("f1", cex = 2) +
  theme(
    aspect.ratio = 1
  )



## -----------------------------------------------------------------------------
df <- inner_join(data_limb, tsne_limb_scaled_with_cluster, by = "ID")

### Define type column
df <- df |>
  select(starts_with("x"), starts_with("emb"), "cluster") |>
  mutate(type = tsne_limb_scaled_with_cluster$cluster) ## original dataset

df_b <- df_bin_limb |>
  filter(h %in% df_bin_centroids_limb$h) |>
  mutate(type = "model") ## Data with summarized mean

## Reorder the rows of df_b according to the h order in model_2d
df_b <- df_b[match(df_bin_centroids_limb$h, df_b$h),] |>
  tidyr::drop_na() |>
  select(-h)

df_exe_limb_int <- bind_rows(df_b, df)

point_data <- df_exe_limb_int 
edge_data <- trimesh_data_limb

num_highd_col <- point_data |>
  dplyr::select(starts_with("x")) |>
  NCOL()

shared_df <- crosstalk::SharedData$new(point_data)

cluster_colors <- c(
    "0" = '#66c2a5', "1" = '#fc8d62', "2" = '#8da0cb',
    "3" = '#e78ac3', "4" = '#a6d854', "5" = '#ffd92f', "6" = '#e5c494'
)

# Scatter points
nldr_plt <- plot_ly(
    data = shared_df,
    x = ~emb1, y = ~emb2,
    type = "scatter", mode = "markers",
    color = ~cluster, colors = cluster_colors,
    marker = list(size = 3, opacity = 0.5),
    hoverinfo = "skip",  # <-- skip hover completely
    showlegend = FALSE
)

# Add line segments
if (nrow(trimesh_data_limb) > 0) {
    nldr_plt <- nldr_plt |>
        add_segments(
            data = trimesh_data_limb,
            x = ~x_from, y = ~y_from,
            xend = ~x_to, yend = ~y_to,
            line = list(color = "#000000", width = 0.5),
            inherit = FALSE,
            showlegend = FALSE,
            hoverinfo = "skip"  # <-- skip hover
        )
}

# Layout: axes, border, no tooltip
nldr_plt <- nldr_plt |>
    layout(
        width = 310, height = 310,
        margin = list(l = 20, r = 20, t = 20, b = 20),
        xaxis = list(title = "", showgrid = FALSE, zeroline = FALSE,
                     showticklabels = FALSE, ticks = "", linecolor = "black", mirror = TRUE),
        yaxis = list(title = "", showgrid = FALSE, zeroline = FALSE,
                     showticklabels = FALSE, ticks = "", linecolor = "black", mirror = TRUE)
    ) |>
    style(
        selected = list(marker = list(opacity = 1)),
        unselected = list(marker = list(opacity = 1))
    ) |>
    highlight(
        on = "plotly_selected",
        off = "plotly_deselect"
    ) |>
    config(displayModeBar = FALSE)


langevitour_output <- langevitour::langevitour(point_data[1:num_highd_col],
                                               lineFrom = edge_data$from_reindexed,
                                               lineTo = edge_data$to_reindexed,
                                               group = factor(point_data$type,
                                                              c("0", "1", "2", "3", "4", "5", "6", "model")),
                                               pointSize = append(rep(point_sizes[1], NROW(df_b)),
                                                                  rep(point_sizes[2], NROW(df))),
                                               levelColors = c('#66c2a5','#fc8d62','#8da0cb','#e78ac3','#a6d854','#ffd92f','#e5c494', "#000000"),
                                               link=shared_df,
                                               linkFilter=FALSE,
                                               width = "370px", height = "370px")

linked_plt_best <- crosstalk::bscols(
    htmltools::div(
        style = "display: grid; grid-template-columns: 1fr 1fr;
    gap: 0px;
    align-items: start;
    justify-items: center;
    margin: 0;
    padding: 0;
    height: 380px;
    width: 500px",
        nldr_plt, 
        htmltools::div(style = "margin-top: 20px;", langevitour_output)
    ),
    device = "xs"
)


## -----------------------------------------------------------------------------
#| label: prep-limb-tsne-best-model-proj

data_limb_n <- data_limb |> 
  select(-ID) |>
  mutate(type = "data")

df_b_limb <- df_bin_limb |>
  dplyr::filter(h %in% df_bin_centroids_limb$h) |>
  dplyr::mutate(type = "model") ## Data with summarized mean

## Reorder the rows of df_b according to the h order in df_b_with_center_data
df_b_limb <- df_b_limb[match(df_bin_centroids_limb$h, df_b_limb$h),] |>
  dplyr::select(-h) 

# Apply the scaling
df_model_data_limb <- bind_rows(data_limb_n, df_b_limb)
scaled_limb <- scale_data_manual(df_model_data_limb, "type") |>
  as_tibble()

scaled_limb_data <- scaled_limb |>
  filter(type == "data") |>
  select(-type)

scaled_limb_data_model <- scaled_limb |>
  filter(type == "model") |>
  select(-type)


## ----plot-proj-best-----------------------------------------------------------

## First projection
projection <- cbind(
  c(-0.021068,0.007018,0.008770,0.016884,-0.008135,0.011458,-0.022323,0.007231,0.004976,-0.019298),
  c(-0.017371,-0.008514,0.003231,-0.022945,-0.026264,-0.001571,0.008007,-0.001268,-0.016923,-0.006700))

proj_obj1 <- get_projection(projection = projection, 
                            proj_scale = 1.23, 
                            highd_data = scaled_limb_data, 
                            model_highd = scaled_limb_data_model, 
                            trimesh_data = trimesh_data_limb, 
                            axis_param = list(limits = 0.05,
                                              axis_scaled = 20, 
                                              axis_pos_x = -0.04, 
                                              axis_pos_y = -0.04, 
                                              threshold = 0.004))

proj_obj1[["cluster"]] <- as.character(tsne_limb_scaled_with_cluster$cluster)

limb_proj_tsne_best_model1 <- plot_proj(
  proj_obj = proj_obj1, 
  point_param = c(1.5, 0.2), # size, alpha, color
  plot_limits = c(-0.05, 0.03), 
  axis_text_size = 4,
  is_category = TRUE) +
  interior_annotation(label = "f2", cex = 2) + 
  scale_color_manual(values = c('#66c2a5','#fc8d62','#8da0cb','#e78ac3','#a6d854','#ffd92f','#e5c494'))

## Second projection
projection <- cbind(
  c(-0.025678,-0.017472,0.015634,-0.014868,-0.000752,0.001050,-0.019524,-0.008076,-0.010808,-0.002319),
  c(0.014526,-0.013526,-0.005147,-0.027612,-0.016919,0.005198,0.010710,0.004623,-0.007055,0.017842))

proj_obj2 <- get_projection(projection = projection, 
                            proj_scale = 1.23, 
                            highd_data = scaled_limb_data, 
                            model_highd = scaled_limb_data_model, 
                            trimesh_data = trimesh_data_limb, 
                            axis_param = list(limits = 0.05,
                                              axis_scaled = 20, 
                                              axis_pos_x = -0.03, 
                                              axis_pos_y = -0.03, 
                                              threshold = 0.004))

proj_obj2[["cluster"]] <- as.character(tsne_limb_scaled_with_cluster$cluster)

limb_proj_tsne_best_model2 <- plot_proj(
  proj_obj = proj_obj2, 
  point_param = c(1.5, 0.2), # size, alpha, color
  plot_limits = c(-0.04, 0.04), 
  axis_text_size = 4,
  is_category = TRUE) +
  interior_annotation(label = "f3", cex = 2) + 
  scale_color_manual(values = c('#66c2a5','#fc8d62','#8da0cb','#e78ac3','#a6d854','#ffd92f','#e5c494'))




## ----model-limb, fig.cap="Compare the published $2\\text{-}D$ layout (Figure \\ref{fig:limb-hbe}a) and the $2\\text{-}D$ layout selected (Figure \\ref{fig:limb-hbe}f) by HBE plot (Figure \\ref{fig:limb-hbe}) from the tSNE, UMAP, PHATE, TriMAP, and PaCMAP with different hyper-parameters. The Limb muscle data ($n =  1067$) has seven close different shaped clusters in $10\\text{-}D$.", fig.alt = "Comparison of published $2\\text{-}D$ layout (b) and the HBE-selected $2\\text{-}D$ layout (f) for the limb muscle data (n = 1067) with seven differently shaped clusters in $10\\text{-}D$, using tSNE, UMAP, PHATE, TriMAP, and PaCMAP with various hyper-parameters.", fig.pos="!ht", fig.width=15, fig.height=10, eval=knitr::is_latex_output()----

trimesh_limb + limb_proj_tsne_model1 +
  limb_proj_tsne_model2 + trimesh_limb_best +
  limb_proj_tsne_best_model1 + limb_proj_tsne_best_model2 +
  plot_layout(nrow = 2)


## ----tsne-link-limb, eval=knitr::is_html_output(), fig.cap="Interactively linked plots connecting layout a (left) and the fitted model overlaid with the limb muscle data in $10\\text{-}D$ (right). Each color represents a different muscle group, with triangulated hexagon centroids on the NLDR layout connected to their corresponding regions in the high-dimensional projection using `langevitour`. Brushing in either view highlights the same subset of points across both panels, enabling exploration of how clusters in the low-dimensional embedding align with structures in the original high-dimensional space. Double-clicking clears the selection and removes highlights.", fig.alt = "Interactive two-panel linked plots showing the published $2\\text{-}D$ layout (b) of limb muscle data on the left and the fitted high-dimensional model in $10\\text{-}D$ on the right using langevitour. Colors indicate different muscle groups. Brushing or selecting points in either panel highlights the corresponding points in the other, illustrating how clusters in the $2\\text{-}D$ embedding correspond to structures in the original $10\\text{-}D$ space.", layout = "l-body"----
# 
# class(linked_plt_int) <- c(class(linked_plt_int), "htmlwidget")
# 
# linked_plt_int


## ----tsne-link-limb-best, eval=knitr::is_html_output(), fig.cap="Interactively linked plots connecting layout f (left) and the fitted model overlaid with the limb muscle data in $10\\text{-}D$ (right). Each color represents a different muscle group, with triangulated hexagon centroids on the NLDR layout connected to their corresponding regions in the high-dimensional projection using `langevitour`. Brushing in either view highlights the same subset of points across both panels, enabling exploration of how clusters in the low-dimensional embedding align with structures in the original high-dimensional space. Double-clicking clears the selection and removes highlights.", fig.alt = "Interactive two-panel linked plots showing the HBE-selected $2\\text{-}D$ layout (f) of limb muscle data on the left and the fitted high-dimensional model in $10\\text{-}D$ on the right using langevitour. Colors indicate different muscle groups. Brushing or selecting points in either panel highlights the corresponding points in the other, showing how clusters in the $2\\text{-}D$ embedding correspond to structures in the original $10\\text{-}D$ space.", layout = "l-body"----
# 
# class(linked_plt_best) <- c(class(linked_plt_best), "htmlwidget")
# 
# linked_plt_best

